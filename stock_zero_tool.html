<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>관리코드별 색상/사이즈 품절툴 (자동 품절 감지)</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <style>
body {
  font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
  background: #f8fcf9;
  color: #163326;
  font-size: 16px;
  margin: 0; padding: 0;
}

/* --- 1. 레이아웃 (3단 구조) --- */
.container {
  max-width: 1800px;
  margin: 22px auto 0 auto;
  padding: 0 24px;
  overflow-x: auto;
  min-height: 96vh;
  display: flex;
  flex-direction: row;
  gap: 24px;
  align-items: flex-start;
}

/* 1단: 메인 영역 (파일, 모드, 코드 목록) */
.main-area {
  flex: 1;
  min-width: 500px;
  background: #fff;
  padding: 30px 42px 38px 42px;
  border-radius: 18px;
  box-shadow: 0 2px 28px rgba(60,80,60,0.09);
}

/* 2단: 컨텍스트 영역 (상세 작업 패널) */
.context-area {
  width: 420px;
  min-width: 400px;
  background: #fdfdfd;
  border: 1px solid #e8f0eb;
  border-radius: 16px;
  box-shadow: 0 2px 12px rgba(120,160,120,0.07);
  padding: 22px 24px;
  align-self: flex-start;
  position: sticky;
  top: 22px;
  height: calc(100vh - 44px);
  overflow-y: auto;
  transition: border-color 0.2s, background 0.2s;
}
.context-placeholder {
  text-align: center;
  padding-top: 60px;
  color: #9ab0a5;
  font-size: 15px;
  font-weight: 500;
  line-height: 1.6;
}

/* 3단: 사이드 영역 (결과 요약) */
.side-area {
  width: 380px;
  min-width: 320px;
  background: #f7faf8;
  border-radius: 16px;
  box-shadow: 0 2px 12px rgba(120,160,120,0.07);
  padding: 18px 22px 24px 22px;
  margin-top: 0;
  align-self: flex-start;
  position: sticky;
  top: 22px;
  height: calc(100vh - 44px);
  display: flex;
  flex-direction: column;
}
.side-area h3 { font-size: 1.1rem; font-weight: 600; color: #195140; margin-bottom: 6px; }
.side-area ul {
  font-size: 14.5px; list-style: none; margin: 0; padding: 0;
  flex: 1; /* 리스트가 남은 공간 차지 */
  overflow-y: auto;
}
.side-area ul li {
  background: #e1ece6; border-radius: 7px;
  margin-bottom: 7px; padding: 6px 11px; color: #315e4d;
  font-weight: 500; word-break: break-all;
}

/* --- 2. 컨트롤 (버튼, 입력 등) --- */
.main-title-wrap {
  display: flex; align-items: flex-end; justify-content: space-between;
  min-height: 48px; margin-bottom: 16px; position: relative; padding-right: 42px;
}
.main-title {
  font-size: 2.2rem; font-weight: 700; color: #184c37;
  margin: 0 0 0 16px; letter-spacing: 0.02em;
}
.back-btn {
  background: #e1ece6; border: 1.2px solid #b0c9bb; color: #246b5c;
  border-radius: 10px; padding: 11px 22px; font-size: 15px; font-weight: 600;
  margin-bottom: 18px; margin-top: 6px; margin-left: 8px; cursor: pointer;
  transition: background 0.13s, color 0.13s;
}
.back-btn:hover { background: #d2e3da; color: #184c37; border-color: #89ac98; }

.file-select-area {
  display: flex; align-items: center; gap: 10px; margin-bottom: 12px;
}
.file-label {
  background: #e1ece6; color: #296149; border: 1.2px solid #b0c9bb;
  border-radius: 10px; padding: 11px 23px; font-size: 15px; font-weight: 600;
  cursor: pointer; display: inline-block; margin-right: 8px;
  transition: background 0.13s; text-align: center;
}
.file-label:hover { background: #d2e3da; color: #184c37; border-color: #89ac98; }
.file-input { display: none; }

.switch-btn {
  min-width: 135px; background: #e1ece6; color: #247467;
  border: 1.2px solid #b0c9bb; border-radius: 10px; padding: 11px 18px;
  font-size: 15px; font-weight: 700; margin-left: 8px; cursor: pointer;
  transition: background 0.14s;
}
.switch-btn.on { background: #61ad80; color: #fff; border-color: #38885b; }

.reset-btn {
  min-width: 72px; margin-left: 8px; background: #f5c8c8; color: #ad2c2c;
  border: 1.2px solid #f3d1d1; font-weight: 500; transition: background 0.12s, color 0.13s;
  padding: 11px 14px; font-size: 14px; border-radius: 10px;
}
.reset-btn:hover { background: #f3b0b0; color: #8a2525; border-color: #e2b1b1; }

.check-row {
  display: flex; align-items: center; gap: 18px; margin: 7px 0 18px 0; font-size: 15px;
}
.check-row input[type="checkbox"] {
  accent-color: #2a6e52; width: 19px; height: 19px;
  vertical-align: middle; margin-right: 5px; margin-top: 1.5px;
}

/* --- 3. 관리코드 버튼 (1단) --- */
#codeBtnArea {
  margin-top: 15px; margin-bottom: 8px;
  display: flex; flex-wrap: wrap; gap: 12px 16px;
}
.code-btn {
  min-width: 128px; max-width: 220px; background: #e1ece6;
  border: 1.2px solid #b0c9bb; border-radius: 13px; font-size: 15px;
  font-weight: 700; color: #255c43; padding: 11px 12px; margin: 0;
  cursor: pointer; transition: background 0.13s, color 0.13s, border 0.13s, box-shadow 0.13s;
  outline: none; box-shadow: 0 1px 3px rgba(60,90,60,0.03);
  text-align: center; word-break: keep-all; overflow: hidden;
  text-overflow: ellipsis; white-space: nowrap; letter-spacing: 0.01em;
}
/* 상태: 개별 품절/단종 있음 */
.code-btn.has-soldout {
  background: #73bc98 !important; color: #fff !important; border-color: #5cb88a;
  filter: brightness(0.98); border-style: dashed;
}
/* 상태: 전체 품절 */
.code-btn.is-soldout-all {
  background: #73bc98 !important; color: #fff !important; border-color: #5cb88a;
}
/* 상태: 전체 단종 */
.code-btn.is-discont-all {
  background: #856ed9 !important; color: #fff !important; border-color: #533e8e;
}
/* 상태: 현재 선택됨 (활성) */
.code-btn.selected {
  box-shadow: 0 0 0 3px #b5e9d6 inset !important;
  border-color: #4bc79f !important; border-width: 2px;
}

/* --- 4. 컨텍스트 패널 내부 (2단) --- */
.context-area h2 {
  font-size: 1.5rem; color: #146f58; margin: 0 0 12px 0;
  word-break: break-all;
}
.context-area .section-title {
  margin-bottom: 10px; font-weight: 600; font-size: 14px;
  color: #2b7365; border-bottom: 1px solid #e0e0e0; padding-bottom: 6px;
}
.context-area .control-grid {
  display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
  margin-bottom: 15px;
}
.context-area .control-grid .switch-btn {
  margin-left: 0; width: 100%; min-width: unset; padding: 14px 10px;
}

/* 2단: 옵션 버튼 그리드 (품절 모드) */
.option-btn-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
  gap: 8px 10px;
  width: 100%;
  margin: 11px 0 6px 0;
}
.option-btn {
  display: inline-block; min-width: 46px; min-height: 28px;
  background: #e1ece6; border: 1.2px solid #b0c9bb; border-radius: 9px;
  font-size: 12px !important; font-weight: 500; color: #315e4d;
  padding: 8px 6px; margin: 0; cursor: pointer;
  transition: background 0.13s, color 0.13s;
  outline: none; text-align: center; box-sizing: border-box;
  word-break: break-all;
}
.option-btn.selected {
  background: #f3d8d8 !important; color: #b45454 !important;
  border-color: #e1bbbb; font-weight: 600;
}
.option-btn.discont {
  background: #533e8e !important; color: #fff !important;
  border-color: #6c4ff8; font-weight: 700;
}

/* 2단: 옵션 편집 폼 (편집 모드) */
.edit-form-area {
  padding: 10px; border:1px solid #cfe3d8; border-radius:8px; margin-bottom:12px;
  background: #fcfefd;
}
.edit-form-area .form-title {
  font-size: 12px; color: #547a6b; margin-bottom: 8px; font-weight: 600;
}
.edit-form-area input[type="text"],
.edit-form-area input[type="number"] {
  flex: 1; padding: 6px 8px; font-size: 13px; border: 1px solid #b0c9bb;
  border-radius: 6px; box-sizing: border-box; width: 100%;
}
.edit-form-area input[type="text"]:disabled { background: #f0f0f0; }
.edit-form-area .input-row { display:flex; gap:6px; margin-bottom:6px; }
.edit-form-area .add-btn {
  width: 100%; padding: 8px; font-size: 14px; background: #2b7365;
  color: #fff; border: none; border-radius: 6px; cursor: pointer;
  font-weight: 600; margin-top: 4px;
}
.edit-form-area .form-help {
  margin-top: 8px; font-size: 11px; color: #7a8d84; line-height: 1.4;
}

/* 2단: 옵션 목록 (편집 모드) */
.option-list-container {
  display: flex; flex-direction: column; gap: 4px;
  max-height: 350px; overflow: auto;
  border: 1px solid #e0eee8; padding: 6px; border-radius: 8px;
}
.opt-file { border:1px solid #e3efe7; border-radius:10px; padding:10px; margin:4px 0; background:#fbfdfc; }
.opt-file__title { font-size:12px; color:#5b7e6f; font-weight:700; margin-bottom:6px; }
.opt-color { padding:8px 10px; border-radius:8px; background:#f5fbf8; border:1px solid #e0eee8; margin:6px 0; }
.opt-color__title { font-size:13px; color:#1f6e59; font-weight:700; margin-bottom:6px; }
.opt-sizes { display:flex; flex-wrap:wrap; gap:6px; }
.size-chip {
  display:inline-flex; align-items:center; gap:6px;
  padding:6px 8px; border-radius:999px;
  background:#e8f3ee; border:1px solid #cfe3d8; font-size:12px; color:#275c4a;
}
.size-chip__stock { font-style:normal; font-size:11px; opacity:.75; }
.size-chip.is-zero { background:#fdecec; border-color:#f3c9c9; color:#a43a3a; }
.opt-empty { color:#9aa8a2; font-size:12px; text-align:center; padding:12px 0; }

/* 2단/3단 공통 닫기/다운로드 버튼 */
.panel-close-btn {
  margin-top: 15px; background: #f8f3f3; border-radius: 8px;
  padding: 10px 0; border: 1.1px solid #eed1d1; font-size: 14px !important;
  color: #c34343; text-align: center; cursor: pointer; width: 100%;
  font-weight: 600; margin-bottom: 0;
}
.download-btn {
  margin-top: 24px; background: #e1ece6; color: #27624f; border: 1.2px solid #b0c9bb;
  border-radius: 11px; padding: 16px 22px; font-size: 17px; font-weight: 700;
  cursor: pointer; min-width: 240px; transition: background 0.13s, color 0.13s;
  display: block; width: 100%; box-sizing: border-box;
  box-shadow: 0 2px 14px rgba(120,180,120,0.09);
}
.download-btn:hover { background: #bce3c7; color: #155c3f; border-color: #5cb88a; }

/* --- 5. 반응형 --- */
@media (max-width: 1500px) {
  .container { flex-direction: column; max-width: 99vw; padding: 22px 3vw; }
  .main-area, .context-area, .side-area {
    min-width: unset; width: 90vw; max-width: 800px;
    margin: 0 auto;
    position: static; height: auto; max-height: unset;
  }
  .context-area { margin-top: 24px; }
  .side-area { margin-top: 24px; }
}
@media (max-width: 660px) {
  .main-title { font-size: 1.8rem; }
  .container { padding: 5vw 0; }
  .main-area, .context-area, .side-area { padding: 18px 4vw; width: 92vw; }
  .file-select-area { flex-wrap: wrap; }
  .code-btn { min-width: 92px; font-size: 13px; padding: 9px 7px; }
}
  </style>
</head>
<body>

  <div class="container">

    <div class="main-area">
      <button class="back-btn" onclick="location.href='https://easyhara.github.io/smartstore_options/smartstore_options.html'">
        &larr; 옵션 자동 생성기로 돌아가기
      </button>
      <div class="main-title-wrap">
        <h1 class="main-title">관리코드별 색상/사이즈 품절툴</h1>
      </div>
      <div style="margin-bottom:12px; font-size:15.5px; line-height:1.54;">
        여러 옵션 파일을 업로드하고 <b style="color:#248960;">관리코드</b>를 클릭하면<br>
        우측 패널에서 <span style="color:#3c6844; font-weight:600;">전체 품절, 개별 품절/단종</span>을 선택하거나 옵션을 편집합니다.<br>
        <span style="color:#c63737;">
        재고가 0인 옵션은 자동으로 품절 상태로 체크됩니다.
        </span>
      </div>

      <div class="file-select-area" id="fileDropZone">
        <label class="file-label">
          엑셀파일선택
          <input type="file" id="inputFiles" class="file-input" multiple accept=".xls,.xlsx">
        </label>
        <span id="fileNames" style="font-size:15px;max-width:360px;display:inline-block;vertical-align:middle;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></span>
        <span id="fileCount" style="font-size:14px;color:#1b8863;margin-left:7px;"></span>
        <button class="reset-btn" id="resetBtn">초기화</button>
      </div>

      <div class="file-select-area">
        <div id="modeSwitchGroup" style="display:flex; align-items:center; gap:6px; margin-left:8px;">
          <button class="switch-btn on" id="modeSoldoutBtn" title="품절/단종 선택 모드">품절/단종 모드</button>
          <button class="switch-btn" id="modeEditBtn" title="옵션 추가/삭제 모드">옵션 편집 모드</button>
        </div>
        <button class="switch-btn" id="setAll99999Btn" title="모든 행 재고를 99999로 설정">모두 99999</button>
      </div>

      <div class="check-row">
        <label>
          <input type="checkbox" id="fillStockCheckbox" checked>
          품절 외 재고 99999
        </label>
        <span id="prodCountInfo" style="font-size:15.2px;color:#3b7c53;"></span>
      </div>

      <div id="codeBtnArea"></div>
    </div>

    <div class="context-area" id="contextArea">
      <div class="context-placeholder">
        &larr; 왼쪽에서 관리코드를 선택하면<br>이곳에 상세 작업 패널이 나타납니다.
      </div>
    </div>

    <div class="side-area">
      <h3>선택된 품절 옵션</h3>
      <ul id="soldoutList">
        <li style="color:#b5b5b5;">(선택내역 없음)</li>
      </ul>
      <button class="download-btn" id="downloadBtn" disabled>선택 품절처리 & 파일 다운로드</button>
    </div>

  </div>

  <script>
// === Global state (필수) ===
let fileList = [];
let fileDataArr = [];
let allRows = [];
let uniqueCodes = [];
let soldoutState = {};
let selectedCode = null;
let mode = 'soldout'; // 'soldout' | 'edit'

// === DOM Elements ===
const codeBtnArea = document.getElementById('codeBtnArea');
const contextArea = document.getElementById('contextArea');
const soldoutListUl = document.getElementById('soldoutList');
const downloadBtn = document.getElementById('downloadBtn');
const inputFilesElem = document.getElementById('inputFiles');
const fileNamesElem = document.getElementById('fileNames');
const fileCountElem = document.getElementById('fileCount');
const prodCountInfoElem = document.getElementById('prodCountInfo');
const modeSoldoutBtn = document.getElementById('modeSoldoutBtn');
const modeEditBtn = document.getElementById('modeEditBtn');


// === 다운로드 직전 검증 (기존 코드 유지) ===
function buildValidationReport() {
  const r = {
    missingCode: [],
    parseFail: [],
    duplicates: [],
    mixedSizePattern: [],
    totals: { rows: allRows.length }
  };
  const dupMap = new Map();
  const mixMap = new Map();
  const sizeSlashRe = /^([A-Za-z0-9]+)\s*\/\s*.+$/;
  allRows.forEach((row, i) => {
    const code = row['관리코드'] || row['상품코드'] || row['코드'] || '';
    if (!code) r.missingCode.push(i);
    const { color, size } = extractColorAndSize(row);
    const label = (row['제품선택'] || row['추가상품값'] || '').toString().trim();
    if (!color && !size && !label) r.parseFail.push(i);
    const k = `${row.file}||${code}||${color}||${size}`;
    if (!dupMap.has(k)) dupMap.set(k, { count: 0, samples: [] });
    const d = dupMap.get(k);
    d.count++;
    if (d.samples.length < 5) d.samples.push(i);
    const bucket = `${row.file}||${code}`;
    const v = (row['사이즈'] ?? '').toString().trim();
    if (v) {
      if (!mixMap.has(bucket)) mixMap.set(bucket, { hasSlash: false, hasPlain: false });
      const cur = mixMap.get(bucket);
      if (sizeSlashRe.test(v)) cur.hasSlash = true; else cur.hasPlain = true;
    }
  });
  dupMap.forEach((v, key) => { if (v.count > 1) r.duplicates.push({ key, count: v.count, samples: v.samples }); });
  mixMap.forEach((v, bucket) => {
    if (v.hasSlash && v.hasPlain) {
      const [file, code] = bucket.split('||');
      r.mixedSizePattern.push({ file, code, detail: '사이즈 열에 접미사 패턴과 순수값이 혼재' });
    }
  });
  r.totals.issues =
    r.missingCode.length + r.parseFail.length + r.duplicates.length + r.mixedSizePattern.length;
  return r;
}
function formatValidationSummary(report) {
  if (!report || !report.totals) return '검증 결과를 생성하지 못했습니다.';
  const lines = [];
  lines.push(`총 행: ${report.totals.rows.toLocaleString()}개`);
  lines.push(`- 관리코드 누락: ${report.missingCode.length}개`);
  lines.push(`- 색상/사이즈 파싱 실패: ${report.parseFail.length}개`);
  lines.push(`- 중복 옵션 키: ${report.duplicates.length}개 그룹`);
  lines.push(`- 혼재된 사이즈 표기: ${report.mixedSizePattern.length}개 그룹`);
  if (report.duplicates.length) {
    const s = report.duplicates.slice(0, 3).map(d => {
      const [file, code, color, size] = d.key.split('||');
      return `  • (${d.count}회) [${file}] ${code} / ${color || '-'} / ${size || '-'}`;
    });
    lines.push('중복 예시:'); lines.push(...s);
  }
  if (report.mixedSizePattern.length) {
    const s = report.mixedSizePattern.slice(0, 3).map(m => `  • [${m.file}] ${m.code} — ${m.detail}`);
    lines.push('혼재 예시:'); lines.push(...s);
  }
  lines.push('');
  lines.push('내려받기를 계속하시겠어요?');
  return lines.join('\n');
}

// === 유틸리티 함수 (기존 코드 유지) ===
function toSafeId(str) { return String(str).replace(/[^a-zA-Z0-9\-_:.]/g, '_'); }
function extractColorAndSize(row) {
  let color = (row['색상']  ?? '').toString().trim();
  let size  = (row['사이즈'] ?? '').toString().trim();
  const label = (row['제품선택'] || row['추가상품값'] || '').toString().trim();
  const tokens = label ? label.split('/').map(s => s.trim()).filter(Boolean) : [];
  const m = color.match(/^([A-Za-z0-9]+)\s*\/\s*(.+)$/);
  if (!size && m && isSizeToken(m[1])) {
    size = m[1].trim();
    for (let i = tokens.length - 1; i >= 0; i--) {
      if (!isSizeToken(tokens[i])) { color = tokens[i]; break; }
    }
  }
  if (!size && tokens.length) {
    for (let i = tokens.length - 1; i >= 0; i--) {
      if (isSizeToken(tokens[i])) { size = tokens[i]; break; }
    }
  }
  if (!color && tokens.length) {
    for (let i = tokens.length - 1; i >= 0; i--) {
      if (!isSizeToken(tokens[i])) { color = tokens[i]; break; }
    }
  }
  if (size && size.includes('/')) size = size.split('/')[0].trim();
  return { color: color || '', size: size || '' };
}
function isSizeToken(v){ return /^(FREE|XS|S|M|L|XL|XXL|\d{2,3})$/i.test(String(v||'').trim()); }
const SIZE_ORDER = ['FREE','XS','S','M','L','XL','XXL'];
function sizeKey(v){
  const u = String(v||'').toUpperCase().trim();
  const idx = SIZE_ORDER.indexOf(u);
  if (idx !== -1) return {t:0, v:idx};
  const n = parseInt(u,10);
  if (!Number.isNaN(n)) return {t:1, v:n};
  return {t:2, v:u};
}
function compareSize(a,b){
  const ka = sizeKey(a), kb = sizeKey(b);
  if (ka.t !== kb.t) return ka.t - kb.t;
  if (ka.v < kb.v) return -1;
  if (ka.v > kb.v) return 1;
  return 0;
}
function labelToTokens(rowOrLabel){
  const raw = typeof rowOrLabel === 'string'
    ? rowOrLabel
    : (rowOrLabel['제품선택'] || rowOrLabel['추가상품값'] || '').toString();
  return raw.split('/').map(s => s.trim()).filter(Boolean);
}
function labelHasColorForCodeInFile(code, file){
  const rows = allRows.filter(r => r.file === file && r.관리코드 === code);
  const colorSetUpper = new Set(
    rows.map(r => (r['색상'] || extractColorAndSize(r).color || '')
          .toString().trim())
        .filter(Boolean)
        .map(c => c.toUpperCase())
  );
  if (colorSetUpper.size === 0) return false;
  return rows.some(r => {
    const toks = labelToTokens(r).map(t => t.toUpperCase());
    for (const C of colorSetUpper) if (toks.includes(C)) return true;
    return false;
  });
}
function buildLabelInsertColorAfterProductForCodeFile(code, file, tplRow, newColor){
  const tokens = labelToTokens(tplRow);
  const colorSetUpper = new Set(
    allRows
      .filter(r => r.file === file && r.관리코드 === code)
      .map(r => {
        let c = (r['색상'] || '').toString().trim();
        if (!c) {
          const ex = extractColorAndSize(r);
          c = ex.color || '';
        }
        return c;
      })
      .filter(Boolean)
      .map(c => c.toUpperCase())
  );
  const filtered = tokens.filter(t => {
    const T = t.toUpperCase();
    return !colorSetUpper.has(T) && !isSizeToken(t);
  });
  const out = [...filtered.slice(0,1), newColor, ...filtered.slice(1)];
  return out.filter(Boolean).join(' / ');
}
function replaceLastSizeTokenInLabel(labelStr, newSize){
  const tokens = labelStr.split('/').map(s => s.trim()).filter(Boolean);
  for (let i = tokens.length - 1; i >= 0; i--){
    if (isSizeToken(tokens[i])) { tokens[i] = newSize; return tokens.join(' / '); }
  }
  return [newSize, ...tokens].join(' / ');
}
function detectSizeDisplayPatternForCodeFile(code, file) {
  const rows = allRows.filter(r => r.file===file && r.관리코드===code);
  for (const r of rows) {
    const v = (r['사이즈'] ?? '').toString().trim();
    const m = v.match(/^([A-Za-z0-9]+)\s*\/\s*(.+)$/);
    if (m && isSizeToken(m[1])) {
      const suf = m[2].trim();
      return { column: '사이즈', suffix: suf, format: val => `${val} / ${suf}`, parse:  row => {
          const vv = (row['사이즈'] ?? '').toString().trim();
          const mm = vv.match(/^([A-Za-z0-9]+)\s*\/\s*(.+)$/);
          return mm ? mm[1].trim() : vv;
        }
      };
    }
  }
  for (const r of rows) {
    const v = (r['사이즈'] ?? '').toString().trim();
    if (v) {
      return { column: '사이즈', suffix: '', format: val => val, parse:  row => (row['사이즈'] ?? '').toString().trim() };
    }
  }
  for (const r of rows) {
    const v = (r['색상'] ?? '').toString().trim();
    const m = v.match(/^([A-Za-z0-9]+)\s*\/\s*(.+)$/);
    if (m && isSizeToken(m[1])) {
      const suf = m[2].trim();
      return { column: '색상', suffix: suf, format: val => `${val} / ${suf}`, parse:  row => {
          const vv = (row['색상'] ?? '').toString().trim();
          const mm = vv.match(/^([A-Za-z0-9]+)\s*\/\s*(.+)$/);
          return mm ? mm[1].trim() : '';
        }
      };
    }
  }
  return { column: null, suffix: '', format: v => v, parse: () => '' };
}
function rowHasColorWithPattern(row, color, pattern){
  const label = (row['제품선택'] || row['추가상품값'] || '').toString();
  const tokens = label.split('/').map(s=>s.trim());
  if (tokens.some(t => t === color)) return true;
  if (pattern.column !== '색상') {
    const ccol = (row['색상'] ?? '').toString().trim();
    if (ccol && ccol === color) return true;
  }
  return false;
}
function reorderColorBlock(file, code, color, pattern){
  const list = [];
  for (let i=0;i<allRows.length;i++){
    const r = allRows[i];
    if (r.file===file && r.관리코드===code && rowHasColorWithPattern(r, color, pattern)){
      list.push({idx:i, row:r});
    }
  }
  if (list.length <= 1) return;
  const baseStart = Math.min(...list.map(o=>o.idx));
  const sortedRows = list.map(o=>o.row).sort((a,b)=>{
    const sa = pattern.parse(a);
    const sb = pattern.parse(b);
    return compareSize(sa, sb);
  });
  const removeIdx = new Set(list.map(o=>o.idx));
  const kept = [];
  for (let i=0;i<allRows.length;i++){
    if (!removeIdx.has(i)) kept.push(allRows[i]);
  }
  kept.splice(baseStart, 0, ...sortedRows);
  allRows = kept;
}
function cssEscapeId(raw) { return String(raw).replace(/([ #;?%&,.+*~\':"!^$[\]()=>|\/@])/g, '\\$1'); }
function getCodeKey(row) {
  const norm = s => String(s).replace(/\s/g, '').toLowerCase();
  const keys = Object.keys(row || {});
  const find = want => keys.find(k => norm(k) === norm(want));
  return find('관리코드') || find('상품코드') || find('코드') || null;
}
function rowsByCode(code) {
  const target = normCode(code);
  return allRows.filter(r => (
    normCode(r['관리코드']) === target ||
    normCode(r['상품코드']) === target ||
    normCode(r['코드'])       === target
  ));
}
function makeDiscontCode(origin) {
  let base = String(origin || '').replace(/^(단종\s*)+/g, '').trim();
  let out = '단종 ' + base;
  if (out.length > 20) {
    const compact = out.replace(/\s+/g, '');
    out = '단종' + compact.slice(2);
    if (out.length > 20) out = out.slice(0, 20);
  }
  return out;
}
function findLastIndex(arr, pred){
  for (let i = arr.length - 1; i >= 0; i--) if (pred(arr[i], i, arr)) return i;
  return -1;
}
function normCode(s) { return String(s ?? '').replace(/\s+/g, '').toUpperCase(); }

// === [신규] 순번 재정렬 유틸 (기존 코드 유지) ===
function getLabelKey(row){
  if (Object.prototype.hasOwnProperty.call(row, '제품선택')) return '제품선택';
  if (Object.prototype.hasOwnProperty.call(row, '추가상품값')) return '추가상품값';
  return null;
}
function hasSeqPrefix(label){ return /^\s*\d+\)\s*/.test(String(label||'')); }
function stripSeqPrefix(label){ return String(label||'').replace(/^\s*\d+\)\s*/, ''); }
function detectSeqWidthInFile(file){
  let width = 2;
  for (const r of allRows){
    if (r.file !== file) continue;
    const key = getLabelKey(r); if (!key) continue;
    const m = String(r[key]||'').match(/^\s*(\d+)\s*/);
    if (m) width = Math.max(width, m[1].length);
  }
  return width;
}
function padSeq(n, width){
  const s = String(n);
  return s.length >= width ? s : '0'.repeat(width - s.length) + s;
}
function renumberProductPrefixesPerFile(file){
  const width = detectSeqWidthInFile(file);
  const firstIdxByCode = new Map();
  for (let i=0; i<allRows.length; i++){
    const r = allRows[i];
    if (r.file !== file) continue;
    const key = getLabelKey(r); if (!key) continue;
    const label = r[key];
    if (!hasSeqPrefix(label)) continue;
    const code = r['관리코드'] || r['상품코드'] || r['코드'] || '';
    if (code && !firstIdxByCode.has(code)) firstIdxByCode.set(code, i);
  }
  const orderedCodes = Array.from(firstIdxByCode.entries())
    .sort((a,b)=>a[1]-b[1])
    .map(([c])=>c);
  orderedCodes.forEach((code, idx)=>{
    const seq = padSeq(idx+1, width);
    for (const r of allRows){
      if (r.file !== file) continue;
      const c = r['관리코드'] || r['상품코드'] || r['코드'] || '';
      if (c !== code) continue;
      const key = getLabelKey(r); if (!key) continue;
      const label = r[key];
      if (!hasSeqPrefix(label)) continue;
      const rest = stripSeqPrefix(label);
      r[key] = `${seq}) ${rest}`;
    }
  });
}
function renumberAllFiles(){
  const files = Array.from(new Set(allRows.map(r=>r.file)));
  files.forEach(renumberProductPrefixesPerFile);
}

// === 이벤트 핸들러 초기화 ===
inputFilesElem.addEventListener('change', async function(e) { await handleFiles(e.target.files); });
document.getElementById('resetBtn').addEventListener('click', resetAll);
document.getElementById('setAll99999Btn').addEventListener('click', setAllStock99999);
modeSoldoutBtn.addEventListener('click', () => setMode('soldout'));
modeEditBtn.addEventListener('click', () => setMode('edit'));
downloadBtn.addEventListener('click', downloadFiles);

// 드래그 앤 드롭
const fileDropZone = document.getElementById('fileDropZone');
fileDropZone.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); fileDropZone.classList.add('dragover'); });
fileDropZone.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); fileDropZone.classList.remove('dragover'); });
fileDropZone.addEventListener('drop', (e) => {
  e.preventDefault(); e.stopPropagation();
  fileDropZone.classList.remove('dragover');
  if (e.dataTransfer.files.length) {
    handleFiles(e.dataTransfer.files);
  }
});

// 바디 클릭 (패널 닫기)
document.body.onclick = function(e) {
  // 클릭된 요소가 3개 패널 중 하나의 자손인지 확인
  const isInsideMain = e.target.closest('.main-area');
  const isInsideContext = e.target.closest('.context-area');
  const isInsideSide = e.target.closest('.side-area');
  
  // 세 패널 바깥의 회색 body 영역을 클릭했을 때만 닫힘
  if (!isInsideMain && !isInsideContext && !isInsideSide) {
    if (selectedCode !== null) {
      selectedCode = null;
      updateCodeBtns();
      clearContextPanel();
    }
  }
};


// === 핵심 로직: 파일 처리 및 리셋 ===

function resetAll() {
  fileList = []; fileDataArr = []; allRows = []; uniqueCodes = []; soldoutState = {}; selectedCode = null;
  fileNamesElem.textContent = '';
  fileCountElem.textContent = '';
  inputFilesElem.value = '';
  prodCountInfoElem.textContent = '';
  codeBtnArea.innerHTML = '';
  updateSoldoutList();
  clearContextPanel();
  downloadBtn.disabled = true;
  setMode('soldout');
}

async function handleFiles(filelist) {
  if (!filelist || filelist.length === 0) return;
  for (let file of filelist) {
    if (fileList.find(f=>f.name===file.name)) continue;
    fileList.push(file);
    let data = await readExcel(file);
    fileDataArr.push({name: file.name, data});
  }
  mergeAllRows();
  updateCodeBtns();
  updateProdCount();
  updateSoldoutList();
  let names = fileList.map(f=>f.name).join(', ');
  if (names.length > 45) {
    let split = names.split(',');
    let shown = split.slice(0,2).join(', ') + ' ...';
    fileNamesElem.textContent = shown;
  } else {
    fileNamesElem.textContent = names;
  }
  fileCountElem.textContent = fileList.length > 1 ? `+${fileList.length}개` : '';
  downloadBtn.disabled = false;
}

function readExcel(file) {
  return new Promise(resolve => {
    const reader = new FileReader();
    reader.onload = e => {
      const data = new Uint8Array(e.target.result);
      const wb = XLSX.read(data, {type:'array'});
      const ws = wb.Sheets[wb.SheetNames[0]];
      let json = XLSX.utils.sheet_to_json(ws, {defval:""});
      resolve(json);
    };
    reader.readAsArrayBuffer(file);
  });
}

// [수정] 파일 통합 및 초기 품절 상태 계산
function mergeAllRows() {
  allRows = [];
  let codeSet = new Set();
  // soldoutState는 초기화하지 않고 누적할지 여부가 중요하지만, 
  // handleFiles 호출 시 계속 추가되는 구조이므로 여기서 초기화하지 않고 
  // 새로 추가된 데이터에 대해서만 처리하거나, 혹은 파일 로드 시점에 전체를 다시 계산하도록 합니다.
  // 여기서는 간단히: 파일 추가될 때마다 전체 allRows를 다시 빌드하고 soldoutState도 새로 계산합니다.
  // (단, 사용자가 이미 수동 조작한 내역이 있다면 유지해야 하므로 주의가 필요하나,
  //  현재 구조상 파일 추가 시 기존 soldoutState를 유지하는게 더 복잡하므로 리셋 후 재계산이 안전합니다.
  //  만약 파일 추가 시 기존 작업 유지하려면 별도 로직 필요. 여기서는 파일 로드 시 자동감지 우선)
  soldoutState = {}; 

  // 1. 데이터 통합
  for (let {name, data} of fileDataArr) {
    data.forEach(row => {
      const code = row['관리코드'] || row['상품코드'] || row['코드'] || '';
      allRows.push({
        ...row,
        file: name,
        관리코드: code,
        _normCode: normCode(code)
      });
      if (code) codeSet.add(code);
    });
  }
  uniqueCodes = Array.from(codeSet);

  // 2. 각 코드별 상태 자동 감지 (단종 및 재고 0 품절)
  for (const code of uniqueCodes) {
    // (A) 단종 감지
    if (typeof code === 'string' && code.trim().startsWith('단종')) {
      soldoutState[code] = { 전체: "discont", 복합: [] };
      continue;
    }

    // (B) 재고 0 감지
    const rows = rowsByCode(code);
    if (rows.length === 0) continue;

    let zeroOptions = [];
    let totalCount = rows.length;
    let zeroCount = 0;

    for (const r of rows) {
       let stockVal = r['재고수량'];
       // 공란이거나 숫자가 아니거나 0 이하면 품절로 간주
       // 주의: 엑셀 공란을 0으로 볼지 여부 -> 보통 0 취급
       let stock = (stockVal === '' || stockVal === null || stockVal === undefined) ? 0 : Number(stockVal);
       
       if (isNaN(stock) || stock <= 0) {
         zeroCount++;
         const { color, size } = extractColorAndSize(r);
         zeroOptions.push({
           색상: color,
           사이즈: size,
           상태: 'soldout'
         });
       }
    }

    if (totalCount > 0 && zeroCount === totalCount) {
      // 모든 옵션 재고 0 -> 전체 품절
      soldoutState[code] = { 전체: "soldout", 복합: [] };
    } else if (zeroCount > 0) {
      // 일부 옵션 재고 0 -> 개별 품절 등록
      // 중복 제거 (같은 옵션이 여러 파일에 있을 수 있음)
      const uniqueZero = [];
      const seen = new Set();
      for (let opt of zeroOptions) {
        const k = `${opt.색상}||${opt.사이즈}`;
        if (!seen.has(k)) {
          seen.add(k);
          uniqueZero.push(opt);
        }
      }
      soldoutState[code] = { 전체: false, 복합: uniqueZero };
    }
  }
}

function setAllStock99999() {
  if (!allRows.length) { alert('먼저 파일을 업로드하세요.'); return; }
  const ok = confirm(
    '모든 파일의 모든 행 재고를 99999로 설정합니다.\n' +
    '※ 단종/품절로 지정된 항목은 다운로드 시 재고 0으로 적용됩니다.\n계속할까요?'
  );
  if (!ok) return;
  for (const r of allRows) { r['재고수량'] = 99999; }
  const fillBox = document.getElementById('fillStockCheckbox');
  if (fillBox) fillBox.checked = false;
  
  // 편집 패널이 열려있다면 갱신
  if (selectedCode && mode === 'edit') {
    renderContextPanel(selectedCode);
  }
  alert('모든 재고를 99999로 설정했습니다.');
}

function setMode(newMode) {
  mode = newMode;
  if (mode === 'soldout') {
    modeSoldoutBtn.classList.add('on');
    modeEditBtn.classList.remove('on');
  } else {
    modeSoldoutBtn.classList.remove('on');
    modeEditBtn.classList.add('on');
  }
  // 모드 변경 시 선택된 코드 패널도 다시 렌더링
  if (selectedCode) {
    renderContextPanel(selectedCode);
  } else {
    clearContextPanel();
  }
}

// === [수정] UI 렌더링 (1단: 코드 버튼) ===

function updateCodeBtns() {
  codeBtnArea.innerHTML = '';
  for (let code of uniqueCodes) {
    if (!code) continue;
    const btn = document.createElement('button');
    btn.id = 'codeBtn_' + toSafeId(code);
    btn.className = 'code-btn';

    // 상태 클래스 적용
    const state = soldoutState[code];
    if (state?.전체 === "discont") {
      btn.classList.add('is-discont-all');
    } else if (state?.전체 === "soldout") {
      btn.classList.add('is-soldout-all');
    } else if ((state?.복합 || []).length > 0) {
      btn.classList.add('has-soldout');
    }

    // 현재 선택된 버튼 (활성)
    if (selectedCode === code) {
      btn.classList.add('selected');
    }

    btn.textContent = code;
    
    // [수정] 버튼 클릭 로직 단순화
    btn.onclick = (e) => {
      e.stopPropagation();
      if (selectedCode === code) {
        // 이미 선택된 버튼 다시 클릭 -> 선택 해제
        selectedCode = null;
        updateCodeBtns();
        clearContextPanel();
      } else {
        // 새 버튼 클릭 -> 선택
        selectedCode = code;
        updateCodeBtns(); // 버튼 목록 갱신 (하이라이트)
        renderContextPanel(code); // 컨텍스트 패널 렌더링
      }
    };
    codeBtnArea.appendChild(btn);
  }
}

// === [신규] UI 렌더링 (2단: 컨텍스트 패널) ===

function clearContextPanel() {
  contextArea.innerHTML = `
    <div class="context-placeholder">
      &larr; 왼쪽에서 관리코드를 선택하면<br>이곳에 상세 작업 패널이 나타납니다.
    </div>`;
  contextArea.style.borderColor = '#e8f0eb';
  contextArea.style.background = '#fdfdfd';
}

function closeContextPanel() {
  selectedCode = null;
  updateCodeBtns();
  clearContextPanel();
}

function renderContextPanel(code) {
  contextArea.innerHTML = ''; // Clear
  contextArea.style.borderColor = '#7ad4b3'; // Highlight panel
  contextArea.style.background = '#fff';

  if (mode === 'soldout') {
    renderSoldoutPanel(contextArea, code);
  } else {
    renderEditPanel(contextArea, code);
  }
}

// [신규] 2단: 품절 모드 패널 렌더링
function renderSoldoutPanel(container, code) {
  const rows = rowsByCode(code);
  let colorSet = new Set(), sizeSet = new Set();
  rows.forEach(r => {
    const { color, size } = extractColorAndSize(r);
    if (color && color !== "") colorSet.add(color);
    if (size && size !== "")  sizeSet.add(size);
  });
  const colors = Array.from(colorSet).filter(Boolean);
  const sizes = Array.from(sizeSet).filter(Boolean).sort(compareSize);

  const state = soldoutState[code];
  const isAllSoldout = state?.전체 === 'soldout';
  const isAllDiscont = state?.전체 === 'discont';

  let html = `
    <h2>${code}</h2>
    <div class="section-title">전체 옵션 처리</div>
    <div class="control-grid">
      <button class="switch-btn ${isAllSoldout ? 'on' : ''}" onclick="setAllSoldout('${code}')">
        ${isAllSoldout ? '전체품절 (ON)' : '전체 품절'}
      </button>
      <button class="switch-btn ${isAllDiscont ? 'on' : ''}" style="background-color: ${isAllDiscont ? '#856ed9' : ''};" onclick="setAllDiscont('${code}')">
        ${isAllDiscont ? '전체단종 (ON)' : '전체 단종'}
      </button>
    </div>

    <div class="section-title" style="margin-top: 20px;">개별 옵션 처리</div>
    <div style="font-size:12.5px; color:#555; margin-bottom: 10px;">
      (클릭 순환: 품절 &rarr; 단종 &rarr; 해제)
    </div>
    <div class="option-btn-grid" id="optionBtnGrid_${toSafeId(code)}">
      </div>
    
    <button class="reset-btn" style="width:100%; margin: 20px 0 10px 0;"
            onclick="event.stopPropagation(); deleteCodeRows('${code}')">
      ⚠️ 이 관리코드 행 전체 삭제
    </button>
    <button class="panel-close-btn" onclick="event.stopPropagation(); closeContextPanel()">
      닫기
    </button>
  `;
  container.innerHTML = html;

  // --- 개별 옵션 버튼 생성 ---
  const grid = container.querySelector(`#optionBtnGrid_${toSafeId(code)}`);
  if (!grid) return;

  function getState(code, color, size) {
    const arr = soldoutState[code]?.복합 || [];
    const nc = (color ?? '').trim();
    const ns = (size  ?? '').trim();
    return arr.find(o => (o.색상 ?? '').trim() === nc && (o.사이즈 ?? '').trim() === ns);
  }

  function createOptionBtn(color, size, label) {
    const b = document.createElement('button');
    b.className = 'option-btn';
    b.textContent = label;
    b.dataset.color = color || '';
    b.dataset.size  = size  || '';

    // 초기 상태 도색
    if (isAllSoldout) b.classList.add('selected');
    else if (isAllDiscont) b.classList.add('discont');
    else {
      let opt = getState(code, color, size);
      if (opt?.상태 === 'discont') b.classList.add('discont');
      else if (opt?.상태 === 'soldout') b.classList.add('selected');
    }

    b.onclick = (e) => {
      e.stopPropagation();
      soldoutState[code] = soldoutState[code] || { 전체: false, 복합: [] };

      // 전체 상태였으면 해제(개별로 전환)
      if (soldoutState[code].전체 === "soldout" || soldoutState[code].전체 === "discont") {
        soldoutState[code].전체 = false;
      }

      let idx = (soldoutState[code].복합 || []).findIndex(o => 
        (o.색상 === color || (!color && !o.색상)) &&
        (o.사이즈 === size || (!size && !o.사이즈))
      );

      if (idx < 0) { // 해제 -> 품절
        soldoutState[code].복합.push(
          color && size ? { 색상: color, 사이즈: size, 상태: "soldout" }
          : color ?       { 색상: color, 상태: "soldout" }
                  :       { 사이즈: size, 상태: "soldout" }
        );
      } else if (soldoutState[code].복합[idx].상태 === "soldout") { // 품절 -> 단종
        soldoutState[code].복합[idx].상태 = "discont";
      } else { // 단종 -> 해제
        soldoutState[code].복합.splice(idx, 1);
      }

      checkAndAutoSetAllOptionState(code); // 전체 승격 여부 계산
      updateSoldoutList(); // [3단] 갱신
      updateCodeBtns();    // [1단] 갱신
      renderSoldoutPanel(container, code); // [2단] 자신 갱신
    };
    grid.appendChild(b);
  }

  // 옵션 버튼 채우기
  if (colors.length && sizes.length) {
    colors.forEach(color => {
      sizes.forEach(size => {
        createOptionBtn(color, size, `${color} / ${size}`);
      });
    });
  } else if (colors.length) {
    colors.forEach(color => { createOptionBtn(color, '', color); });
  } else if (sizes.length) {
    sizes.forEach(size => { createOptionBtn('', size, size); });
  } else {
    grid.innerHTML = `<div class="opt-empty" style="grid-column: 1 / -1;">옵션을 찾을 수 없습니다.</div>`;
  }
}

// [신규] 2단: 품절 모드용 헬퍼 함수
function setAllSoldout(code) {
  soldoutState[code] = soldoutState[code] || { 전체: false, 복합: [] };
  if (soldoutState[code].전체 === 'soldout') {
    soldoutState[code].전체 = false; // Toggle off
  } else {
    soldoutState[code].전체 = 'soldout'; // Set
    soldoutState[code].복합 = []; // Clear individuals
  }
  updateSoldoutList();
  updateCodeBtns();
  renderContextPanel(code); // Re-render panel
}

function setAllDiscont(code) {
  soldoutState[code] = soldoutState[code] || { 전체: false, 복합: [] };
  if (soldoutState[code].전체 === 'discont') {
    soldoutState[code].전체 = false; // Toggle off
  } else {
    soldoutState[code].전체 = 'discont'; // Set
    soldoutState[code].복합 = []; // Clear individuals
  }
  updateSoldoutList();
  updateCodeBtns();
  renderContextPanel(code); // Re-render panel
}

// [신규] 2단: 편집 모드 패널 렌더링
function renderEditPanel(container, code) {
  const rowsOnlyThisCode = rowsByCode(code);
  const template = rowsOnlyThisCode[0] || {};
  const hasSizeCol = Object.prototype.hasOwnProperty.call(template, '사이즈');

  const boxHTML = `
    <h2>${code}</h2>
    <div class="section-title">새 옵션 추가</div>
    
    <div class="edit-form-area">
      <div class="input-row">
        <input type="text" id="newColor_${code}" placeholder="색상">
        <input type="text" id="newSize_${code}" placeholder="${hasSizeCol ? '사이즈' : '사이즈 열 없음'}"
               ${hasSizeCol ? '' : 'disabled'}>
      </div>
      <div class="input-row">
        <input type="number" id="newStock_${code}" placeholder="재고수량(기본: 99999)" value="99999">
      </div>
      <button id="addBtn_${code}" class="add-btn">
        + 추가
      </button>
      <div class="form-help">
        • 색상만 입력 → 모든 기존 사이즈로 일괄 추가<br>
        • 사이즈만 입력 → 모든 기존 색상으로 일괄 추가<br>
        • 둘 다 입력 → 해당 조합 1개 추가/갱신
      </div>
    </div>

    <div class="section-title" style="margin-top: 20px;">현재 옵션 목록</div>
    <div id="optionList_${code}" class="option-list-container">
      ${renderOptionListHTML(code)}
    </div>

    <button class="reset-btn" style="width:100%; margin: 20px 0 10px 0;"
            onclick="event.stopPropagation(); deleteCodeRows('${code}')">
      ⚠️ 이 관리코드 행 전체 삭제
    </button>
    <button class="panel-close-btn" onclick="event.stopPropagation(); closeContextPanel()">
      닫기
    </button>
  `;
  container.innerHTML = boxHTML;

  // 추가 버튼 이벤트 바인딩
  const addBtn = container.querySelector(`#addBtn_${cssEscapeId(code)}`) || container.querySelector(`#addBtn_${code}`);
  if (addBtn) {
    addBtn.onclick = (e) => {
      e.stopPropagation();
      addNewOption(code); // 옵션 추가 로직 실행
      // addNewOption이 내부적으로 listEl을 갱신함
    };
  }
}

// [수정] 2단: 편집 모드 - 옵션 목록 HTML 생성 (기존 로직 유지)
function renderOptionListHTML(code) {
  const rowsForCode = rowsByCode(code);
  if (!rowsForCode.length) return `<div class="opt-empty">옵션이 없습니다.</div>`;

  const byFile = {};
  rowsForCode.forEach(r => {
    const ex = extractColorAndSize(r);
    const file = r.file;
    const color = (r['색상'] || ex.color || '').toString().trim() || '(색상없음)';
    const size  = (r['사이즈'] || ex.size  || '').toString().trim()  || '(사이즈없음)';
    const stock = r['재고수량'];
    byFile[file] ??= {};
    byFile[file][color] ??= [];
    byFile[file][color].push({ row: r, color, size, stock });
  });

  let html = '';
  Object.keys(byFile).sort().forEach(file => {
    html += `
      <div class="opt-file">
        <div class="opt-file__title">${file}</div>
      `;
    const byColor = byFile[file];
    Object.keys(byColor).sort((a,b)=>a.localeCompare(b,'ko')).forEach(color => {
      const list = byColor[color].sort((a,b)=>compareSize(a.size, b.size));
      html += `<div class="opt-color">
        <div class="opt-color__title">${color}</div>
        <div class="opt-sizes">`;
      list.forEach(item => {
        const zero = Number(item.stock) === 0;
        html += `
          <span class="size-chip ${zero ? 'is-zero' : ''}" title="재고: ${item.stock}">
            ${item.size}
            <em class="size-chip__stock">${item.stock}</em>
          </span>`;
      });
      html += `</div></div>`;
    });
    html += `</div>`;
  });
  if (!html) html = `<div class="opt-empty">옵션이 없습니다.</div>`;
  return html;
}

// === [수정] UI 렌더링 (3단: 요약 리스트) ===

function updateSoldoutList() {
  soldoutListUl.innerHTML = '';
  let any = false;
  for (let code of uniqueCodes) {
    if (soldoutState[code]?.전체 === "discont") {
      soldoutListUl.innerHTML += `<li><b>${code}</b> <span style="color:#533e8e;font-weight:700;">전체단종</span></li>`;
      any = true;
    } else if (soldoutState[code]?.전체 === "soldout") {
      soldoutListUl.innerHTML += `<li><b>${code}</b> <span style="color:#606060;font-weight:700;">전체품절</span></li>`;
      any = true;
    } else if ((soldoutState[code]?.복합||[]).length > 0) {
      for (let opt of soldoutState[code].복합) {
        let stateLabel = opt.상태 === "discont" ? '<span style="color:#533e8e;font-weight:700;">단종</span>' : '품절';
        soldoutListUl.innerHTML += `<li><b>${code}</b> ${opt.색상?opt.색상+'/':''}${opt.사이즈||''} ${stateLabel}</li>`;
        any = true;
      }
    }
  }
  if (!any) soldoutListUl.innerHTML = `<li style="color:#b5b5b5;">(선택내역 없음)</li>`;
}

// === [수정] 핵심 로직 (옵션 추가, 삭제, 다운로드) ===

// [수정] addNewOption: 팝업 대신 패널 내부 리스트 갱신
function addNewOption(code) {
  const colorInput = document.getElementById(`newColor_${code}`).value.trim();
  const sizeInput  = document.getElementById(`newSize_${code}`)?.value.trim() || '';
  const stock      = parseInt(document.getElementById(`newStock_${code}`).value.trim(), 10) || 99999;
  if (!colorInput && !sizeInput) { alert("색상 또는 사이즈 중 최소 하나는 입력하세요."); return; }

  const listForCode = rowsByCode(code);
  const filesForCode = Array.from(new Set(listForCode.map(r => r.file)));

  filesForCode.forEach(fileName => {
    const template = listForCode.find(r => r.file === fileName);
    if (!template) return;

    const pattern = detectSizeDisplayPatternForCodeFile(code, fileName);
    const useColorInLabel = labelHasColorForCodeInFile(code, fileName);
    const useSizeInLabel  = (() => {
      const tokens = labelToTokens(template);
      return tokens.some(isSizeToken);
    })();

    const colorsToUse = colorInput
      ? [colorInput]
      : (Array.from(new Set(
          allRows
            .filter(r => r.file === fileName && r.관리코드 === code)
            .map(r => r['색상'] || extractColorAndSize(r).color || '')
            .filter(Boolean)
        )) || ['']);

    let sizesToUse;
    if (sizeInput) sizesToUse = [sizeInput];
    else {
      const inFileRows = allRows.filter(r => r.file === fileName && r.관리코드 === code);
      const fromPattern = inFileRows.map(r => pattern.parse(r)).filter(Boolean);
      sizesToUse = fromPattern.length ? Array.from(new Set(fromPattern)) : [''];
    }
    sizesToUse = [...sizesToUse].sort(compareSize);

    colorsToUse.forEach(col => {
      sizesToUse.forEach(sz => {
        let labelValue = (template['제품선택'] || template['추가상품값'] || '').toString();
        if (useColorInLabel && col) labelValue = buildLabelInsertColorAfterProductForCodeFile(code, fileName, template, col);
        if (useSizeInLabel && sz)  labelValue = replaceLastSizeTokenInLabel(labelValue, sz);

        const existIdx = allRows.findIndex(r => {
          if (r.file !== fileName || r.관리코드 !== code) return false;
          if (!rowHasColorWithPattern(r, col, pattern)) return false;
          const existingSize = pattern.parse(r);
          return (existingSize || '') === (sz || '');
        });

        if (existIdx >= 0) {
          const row = allRows[existIdx];
          row['재고수량'] = stock;
          if (pattern.column === '사이즈') {
            if ('사이즈' in row) row['사이즈'] = pattern.format(sz || '');
            if ('색상' in row && !useColorInLabel) row['색상'] = col || row['색상'];
          } else if (pattern.column === '색상') {
            if ('색상' in row) row['색상'] = pattern.format(sz);
          }
          if ('제품선택'    in row) row['제품선택']    = labelValue;
          if ('추가상품값' in row) row['추가상품값'] = labelValue;
        } else {
          const newRow = { ...template };
          newRow['관리코드'] = code;
          if ('상품코드' in newRow) newRow['상품코드'] = code;
          if ('코드'      in newRow) newRow['코드']      = code;
          newRow._normCode = normCode(code);
          newRow['재고수량'] = stock;
          newRow.file = fileName;

          if (pattern.column === '사이즈') {
            if ('사이즈' in newRow) newRow['사이즈'] = pattern.format(sz || '');
            if ('색상' in newRow && !useColorInLabel) newRow['색상'] = col || (newRow['색상'] || '');
          } else if (pattern.column === '색상') {
            if ('색상' in newRow) newRow['색상'] = pattern.format(sz);
          }
          if ('제품선택'    in newRow) newRow['제품선택']    = labelValue;
          if ('추가상품값' in newRow) newRow['추가상품값'] = labelValue;

          const lastSameColorIdx = findLastIndex(allRows, r => {
            if (r.file !== fileName || r.관리코드 !== code) return false;
            return rowHasColorWithPattern(r, col, pattern);
          });
          const lastCodeIdx = findLastIndex(allRows, r => r.file === fileName && r.관리코드 === code);
          const insertAt = (lastSameColorIdx >= 0 ? lastSameColorIdx : lastCodeIdx) + 1;
          allRows.splice(insertAt, 0, newRow);
        }
      });
      reorderColorBlock(fileName, code, col, detectSizeDisplayPatternForCodeFile(code, fileName));
    });
  });

  // UI 갱신
  const listEl = document.getElementById(`optionList_${code}`);
  if (listEl) {
    listEl.innerHTML = renderOptionListHTML(code);
  }
  const cEl  = document.getElementById(`newColor_${code}`);
  const sEl  = document.getElementById(`newSize_${code}`);
  const stEl = document.getElementById(`newStock_${code}`);
  if (cEl) cEl.value = '';
  if (sEl) sEl.value = '';
  if (stEl) stEl.value = '99999';
}

// [수정] deleteCodeRows: 패널 닫기 추가
function deleteCodeRows(code) {
  const target = normCode(code);
  const before = allRows.length;
  if (!confirm(`관리코드 "${code}"에 해당하는 모든 행을 삭제할까요?\n\n⚠️ 되돌리기는 새로고침 전까지 불가합니다.`)) {
    return;
  }

  allRows = allRows.filter(r => (
    normCode(r['관리코드']) !== target &&
    normCode(r['상품코드']) !== target &&
    normCode(r['코드'])       !== target
  ));

  delete soldoutState[code];
  const set = new Set();
  allRows.forEach(r => {
    const c = r['관리코드'] || r['상품코드'] || r['코드'] || '';
    if (c) set.add(c);
  });
  uniqueCodes = Array.from(set);

  renumberAllFiles();
  selectedCode = null;
  updateCodeBtns();    // [1단] 갱신
  clearContextPanel(); // [2단] 갱신
  updateProdCount();
  updateSoldoutList(); // [3단] 갱신

  alert(`삭제 완료: ${before - allRows.length}개 행`);
}

// [수정] checkAndAutoSetAllOptionState: UI 갱신 로직 제거 (상위 호출자가 담당)
function checkAndAutoSetAllOptionState(code) {
  const rows = rowsByCode(code);
  const totalCnt = rows.length;
  let soldoutCnt = 0, discontCnt = 0;
  soldoutState[code] = soldoutState[code] || { 전체: false, 복합: [] };
  const isMatch = (opt, color, size) => {
    const oc = (opt.색상 ?? '').trim();
    const os = (opt.사이즈 ?? '').trim();
    const rc = (color ?? '').trim();
    const rs = (size  ?? '').trim();
    const colorOK = (oc === '' || oc === rc);
    const sizeOK  = (os === '' || os === rs);
    return colorOK && sizeOK;
  };
  for (const r of rows) {
    const { color, size } = extractColorAndSize(r);
    const match = (soldoutState[code].복합 || []).find(o => isMatch(o, color, size));
    if (match) {
      if (match.상태 === 'discont') discontCnt++;
      else if (match.상태 === 'soldout') soldoutCnt++;
    }
  }
  if (totalCnt > 0 && discontCnt === totalCnt) {
    soldoutState[code].전체 = 'discont';
    soldoutState[code].복합 = [];
  } else if (totalCnt > 0 && (soldoutCnt + discontCnt) === totalCnt) {
    soldoutState[code].전체 = 'soldout';
    soldoutState[code].복합 = [];
  } else {
    soldoutState[code].전체 = false;
  }
  // UI 갱신은 이 함수를 호출한 곳(예: 버튼 클릭 핸들러)에서 수행
}

function updateProdCount() {
  prodCountInfoElem.textContent = uniqueCodes.length
    ? `총 ${uniqueCodes.length}개 관리코드` : '';
}

// [수정] downloadFiles: 함수명 변경 및 기존 로직 유지
async function downloadFiles() {
  const report = buildValidationReport();
  const msg = formatValidationSummary(report);
  if (report.totals.issues > 0) {
    if (!confirm(msg)) return;
  }
  const fillStock = document.getElementById('fillStockCheckbox').checked;
  if (typeof JSZip === 'undefined') {
    alert('JSZip 로드에 실패했습니다. 인터넷 연결/스크립트 경로를 확인하세요.');
    return;
  }
  const mainZip = new JSZip();
  const codeOptionCount = {};
  for (const row of allRows) {
    const code = row['관리코드'] || row['상품코드'] || row['코드'] || '';
    if (!code) continue;
    codeOptionCount[code] ??= { total: 0, soldout: 0, discont: 0 };
    codeOptionCount[code].total++;
    const target = soldoutState[code];
    let isSoldout = false, isDiscont = false;
    if ((target?.복합 || []).length > 0) {
      const { color, size } = extractColorAndSize(row);
      for (const opt of target.복합) {
        const matchColor = (!opt.색상 || color === opt.색상);
        const matchSize  = (!opt.사이즈 || size  === opt.사이즈);
        if (matchColor && matchSize) {
          if (opt.상태 === 'discont') isDiscont = true;
          if (opt.상태 === 'soldout') isSoldout = true;
        }
      }
    }
    if (target?.전체 === 'discont') isDiscont = true;
    else if (target?.전체 === 'soldout') isSoldout = true;
    if (isDiscont) codeOptionCount[code].discont++;
    else if (isSoldout) codeOptionCount[code].soldout++;
  }
  for (const code in codeOptionCount) {
    const stat = codeOptionCount[code];
    if (stat.discont === stat.total) {
      soldoutState[code] ??= { 전체: false, 복합: [] };
      soldoutState[code].전체 = 'discont';
      soldoutState[code].복합 = [];
    } else if (stat.soldout + stat.discont === stat.total) {
      soldoutState[code] ??= { 전체: false, 복합: [] };
      if (soldoutState[code].전체 !== 'discont') {
        soldoutState[code].전체 = 'soldout';
        soldoutState[code].복합 = [];
      }
    }
  }
  renumberAllFiles();
  const rowsByFile = {};
  for (const r of allRows) {
    const fname = r.file || '편집추가.xlsx';
    (rowsByFile[fname] ??= []).push(r);
  }
  for (const name in rowsByFile) {
    const data = rowsByFile[name];
    const newData = data.map(row => {
      const codeKey = getCodeKey(row);
      const code = codeKey ? row[codeKey] : '';
      const target = soldoutState[code];
      let isSoldout = false, isDiscont = false;
      if ((target?.복합 || []).length > 0) {
        const { color, size } = extractColorAndSize(row);
        for (const opt of target.복합) {
          const matchColor = (!opt.색상 || color === opt.색상);
          const matchSize  = (!opt.사이즈 || size  === opt.사이즈);
          if (matchColor && matchSize) {
            if (opt.상태 === 'discont') isDiscont = true;
            if (opt.상태 === 'soldout') isSoldout = true;
          }
        }
      }
      if (target?.전체 === 'discont') isDiscont = true;
      else if (target?.전체 === 'soldout') isSoldout = true;
      const rowCopy = { ...row };
      if (isDiscont) {
        if (codeKey) rowCopy[codeKey] = makeDiscontCode(rowCopy[codeKey]);
        rowCopy['재고수량'] = 0;
      } else if (isSoldout || String(code || '').trim().startsWith('단종')) {
        if (String(code || '').trim().startsWith('단종') && codeKey) {
          rowCopy[codeKey] = makeDiscontCode(rowCopy[codeKey]);
        }
        rowCopy['재고수량'] = 0;
      } else if (fillStock && (!rowCopy['재고수량'] || rowCopy['재고수량'] == 0)) {
        rowCopy['재고수량'] = 99999;
      }
      delete rowCopy.file;
      delete rowCopy._normCode;
      return rowCopy;
    });
    const ws = XLSX.utils.json_to_sheet(newData);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
    const xlsBlob = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
    const outName = name.endsWith('.xlsx') ? name : name.replace(/\.xls$/i, '.xlsx');
    mainZip.file(outName, xlsBlob);
  }
  const outBlob = await mainZip.generateAsync({ type: 'blob' });
  saveAs(outBlob, '품절처리_일괄다운로드.zip');
}

  </script>
</body>
</html>
