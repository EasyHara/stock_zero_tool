<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>관리코드별 색상/사이즈 품절툴</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <meta name="viewport" content="width=1200">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <style>
body {
  font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
  background: #f8fcf9;
  color: #163326;
  font-size: 16px;
  margin: 0; padding: 0;
}
.container {
  max-width: 1500px;
  margin: 22px auto 0 auto;
  background: #fff;
  padding: 30px 42px 38px 42px;
  border-radius: 18px;
  box-shadow: 0 2px 28px rgba(60,80,60,0.09);
  overflow-x: auto;
  min-height: 96vh;
  display: flex;
  flex-direction: row;
}
.main-area {
  flex: 1; min-width: 900px; margin-right: 32px;
}
.side-area {
  width: 380px; min-width: 320px;
  background: #f7faf8;
  border-radius: 16px;
  box-shadow: 0 2px 12px rgba(120,160,120,0.07);
  padding: 18px 22px 18px 22px;
  margin-top: 22px;
  align-self: flex-start;
  position: sticky; top: 32px; height: fit-content;
}
.side-area h3 { font-size: 1.1rem; font-weight: 600; color: #195140; margin-bottom: 6px; }
.side-area ul {
  font-size: 14.5px; list-style: none; margin: 0; padding: 0;
}
.side-area ul li {
  background: #e1ece6; border-radius: 7px;
  margin-bottom: 7px; padding: 6px 11px; color: #315e4d;
  font-weight: 500; word-break: break-all;
}
.main-title-wrap {
  display: flex; align-items: flex-end; justify-content: space-between;
  min-height: 48px; margin-bottom: 16px; position: relative; padding-right: 42px;
}
.main-title {
  font-size: 2.2rem; font-weight: 700; color: #184c37;
  margin: 0 0 0 16px; letter-spacing: 0.02em;
}
.back-btn {
  background: #e1ece6;
  border: 1.2px solid #b0c9bb;
  color: #246b5c;
  border-radius: 10px;
  padding: 11px 22px;
  font-size: 15px;
  font-weight: 600;
  margin-bottom: 18px;
  margin-top: 6px;
  margin-left: 8px;
  cursor: pointer;
  transition: background 0.13s, color 0.13s;
}
.back-btn:hover {
  background: #d2e3da;
  color: #184c37;
  border-color: #89ac98;
}

.file-select-area {
  display: flex; align-items: center; gap: 10px; margin-bottom: 12px;
}
.file-label {
  background: #e1ece6;
  color: #296149;
  border: 1.2px solid #b0c9bb;
  border-radius: 10px;
  padding: 11px 23px;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  display: inline-block;
  margin-right: 8px;
  transition: background 0.13s; text-align: center;
}
.file-label:hover { background: #d2e3da; color: #184c37; border-color: #89ac98; }
.file-input { display: none; }

.switch-btn {
  min-width: 135px;
  background: #e1ece6;
  color: #247467;
  border: 1.2px solid #b0c9bb;
  border-radius: 10px;
  padding: 11px 18px;
  font-size: 15px;
  font-weight: 700;
  margin-left: 8px;
  cursor: pointer;
  transition: background 0.14s;
}
.switch-btn.on { background: #61ad80; color: #fff; border-color: #38885b; }

.reset-btn {
  min-width: 72px; margin-left: 8px; background: #f5c8c8; color: #ad2c2c;
  border: 1.2px solid #f3d1d1; font-weight: 500; transition: background 0.12s, color 0.13s; padding: 11px 14px;
  font-size: 14px; border-radius: 10px;
}
.reset-btn:hover { background: #f3b0b0; color: #8a2525; border-color: #e2b1b1; }

.check-row {
  display: flex; align-items: center; gap: 18px; margin: 7px 0 18px 0; font-size: 15px;
}
.check-row input[type="checkbox"] {
  accent-color: #2a6e52; width: 19px; height: 19px; vertical-align: middle; margin-right: 5px; margin-top: 1.5px;
}

/* 관리코드 옵션 버튼 */
#codeBtnArea {
  margin-top: 15px;
  margin-bottom: 8px;
  display: flex;
  flex-wrap: wrap;
  gap: 12px 16px;
}
.code-btn-wrap {
  position: relative;
  display: inline-block;
  vertical-align: top;
}
.code-btn {
  min-width: 128px;
  max-width: 220px;
  background: #e1ece6;
  border: 1.2px solid #b0c9bb;
  border-radius: 13px;
  font-size: 15px;
  font-weight: 700;
  color: #255c43;
  padding: 11px 12px;
  margin: 0;
  cursor: pointer;
  transition: background 0.13s, color 0.13s;
  outline: none;
  box-shadow: 0 1px 3px rgba(60,90,60,0.03);
  text-align: center;
  word-break: keep-all;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  letter-spacing: 0.01em;
}
.code-btn.selected, .code-btn.has-soldout {
  background: #73bc98 !important; color: #fff !important; border-color: #5cb88a;
}

.code-btn.selected { box-shadow: 0 0 0 2px #b5e9d6 inset; border-width: 2px; }
.code-btn.has-soldout:not(.selected) { filter: brightness(0.98); border-style: dashed; }

/* 옵션 선택 박스 (popup) - "색상/사이즈 옵션을 선택하세요." */
.option-select-area.popup {
  position: absolute;
  left: 0;
  top: calc(100% + 15px); /* 버튼 아래로 충분히 여백 */
  z-index: 20;
  min-width: 220px;
  max-width: 320px;
  box-shadow: 0 6px 36px rgba(80,100,80,0.14);
  background: #fff;
  border: 1.5px solid #7ad4b3;
  padding: 18px 13px 16px 13px;
  margin: 0;
  border-radius: 11px;
  text-align: left;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.option-select-area .option-btn-grid {
  display: grid;
  grid-template-columns: repeat(3, minmax(46px, 1fr));
  gap: 8px 10px;
  width: 100%;
  margin: 11px 0 6px 0;
}

/* 옵션 선택 박스 내부 옵션 버튼 */
.option-btn {
  display: inline-block;
  min-width: 46px;
  min-height: 28px;
  background: #e1ece6;
  border: 1.2px solid #b0c9bb;
  border-radius: 9px;
  font-size: 12px !important;
  font-weight: 500;
  color: #315e4d;
  padding: 8px 0;
  margin: 0;
  cursor: pointer;
  transition: background 0.13s, color 0.13s;
  outline: none;
  text-align: center;
  box-sizing: border-box;
}


/* 옵션 선택 팝업 닫기 버튼 */
.option-soldout-area {
  margin-top: 6px;
  background: #f8f3f3;
  border-radius: 8px;
  padding: 10px 0;
  border: 1.1px solid #eed1d1;
  font-size: 14px !important;
  color: #c34343;
  text-align: center;
  cursor: pointer;
  width: 100%;
  font-weight: 600;
  margin-bottom: 0;
}

.download-btn {
  margin-top: 36px; background: #e1ece6; color: #27624f; border: 1.2px solid #b0c9bb;
  border-radius: 11px; padding: 16px 22px; font-size: 17px; font-weight: 700; cursor: pointer;
  min-width: 240px; transition: background 0.13s, color 0.13s;
  display: block; margin-left: auto; margin-right: auto;
  box-shadow: 0 2px 14px rgba(120,180,120,0.09);
}
.download-btn:hover { background: #bce3c7; color: #155c3f; border-color: #5cb88a; }

.option-btn.selected {
  background: #f3d8d8 !important;
  color: #b45454 !important;
  border-color: #e1bbbb;
  font-weight: 600;
}
.option-btn.discont {
  background: #533e8e !important;
  color: #fff !important;
  border-color: #6c4ff8;
  font-weight: 700;
}
.code-btn.discont { background: #856ed9 !important; color: #fff !important; border-color: #533e8e; }

#fileDropZone.dragover {
  background: #c9e8de;
  border-radius: 13px;
  box-shadow: 0 0 0 3px #2ba87d7a;
}

.code-btn[style*="box-shadow"] {
  outline: 2.5px solid #7ae8c8;
}
.switch-btn {
  padding: 6px 12px;
  border-radius: 6px;
  border: 1px solid #ccc;
  background: #f4f4f4;
  cursor: pointer;
  font-size: 14px;
}
.switch-btn.on {
  background: #2b7365;
  color: #fff;
  border-color: #2b7365;
}

/* --- 옵션 목록(편집 모드) 카드형 보기 --- */
.opt-file { border:1px solid #e3efe7; border-radius:10px; padding:10px; margin:8px 0; background:#fbfdfc; }
.opt-file__title { font-size:12px; color:#5b7e6f; font-weight:700; margin-bottom:6px; }

.opt-color { padding:8px 10px; border-radius:8px; background:#f5fbf8; border:1px solid #e0eee8; margin:6px 0; }
.opt-color__title { font-size:13px; color:#1f6e59; font-weight:700; margin-bottom:6px; }

.opt-sizes { display:flex; flex-wrap:wrap; gap:6px; }
.size-chip {
  display:inline-flex; align-items:center; gap:6px;
  padding:6px 8px; border-radius:999px;
  background:#e8f3ee; border:1px solid #cfe3d8; font-size:12px; color:#275c4a;
}
.size-chip__stock { font-style:normal; font-size:11px; opacity:.75; }
.size-chip.is-zero { background:#fdecec; border-color:#f3c9c9; color:#a43a3a; }
.opt-empty { color:#9aa8a2; font-size:12px; text-align:center; padding:12px 0; }

@media (max-width: 1100px) {
  .container { flex-direction: column; max-width: 99vw; padding: 22px 3vw; }
  .main-area, .side-area { min-width: unset; width: unset; }
  .side-area { margin-top: 30px; width: 96vw; max-width: 460px; }
  .code-btn { min-width: 92px; font-size: 13px; padding: 9px 7px; }
}
@media (max-width: 660px) {
  .main-title { font-size: 1.1rem; }
  .container { padding: 5vw 0; }
  .side-area { padding: 6px 2vw; }
}
  </style>
</head>
<body>
  <div class="container">
    <div class="main-area">
      <button class="back-btn" onclick="location.href='https://easyhara.github.io/smartstore_options/smartstore_options.html'">
        &larr; 옵션 자동 생성기로 돌아가기
      </button>
      <div class="main-title-wrap">
        <h1 class="main-title">관리코드별 색상/사이즈 품절툴</h1>
      </div>
      <div style="margin-bottom:12px; font-size:15.5px; line-height:1.54;">
        여러 옵션 파일을 업로드하고<br>
        <b style="color:#248960;">관리코드</b>를 클릭하면 전체 품절, 또는<br>
        <span style="color:#3c6844; font-weight:600;">색상·사이즈별 품절</span>을 선택해서 원하는 옵션만 재고 0(품절)로 변경합니다.<br>
        <span style="color:#c63737;">
        옵션 이름은 반드시 각 행의 ‘색상’, ‘사이즈’ 컬럼에 정확히 입력되어 있어야 합니다.
        </span>
      </div>
      <div class="file-select-area" id="fileDropZone">
        <label class="file-label">
          엑셀파일선택
          <input type="file" id="inputFiles" class="file-input" multiple accept=".xls,.xlsx">
        </label>
        <span id="fileNames" style="font-size:15px;max-width:360px;display:inline-block;vertical-align:middle;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></span>
        <span id="fileCount" style="font-size:14px;color:#1b8863;margin-left:7px;"></span>
       <div id="modeSwitchGroup" style="display:flex; align-items:center; gap:6px; margin-left:8px;">
        <button class="switch-btn on"  id="modeSoldoutBtn"  title="품절/단종 선택 모드">품절/단종 모드</button>
        <button class="switch-btn"      id="modeEditBtn"     title="옵션 추가/삭제 모드">옵션 편집 모드</button>
        </div>
        <button class="switch-btn" id="toggleOptionModeBtn">색상,사이즈별 품절 OFF</button>
        <button class="reset-btn" id="resetBtn">초기화</button>
      </div>

      <div class="check-row">
        <label>
          <input type="checkbox" id="fillStockCheckbox" checked>
          품절 외 재고 99999
        </label>
        <span id="prodCountInfo" style="font-size:15.2px;color:#3b7c53;"></span>
      </div>
      <div id="codeBtnArea"></div>
      <button class="download-btn" id="downloadBtn" disabled>선택 품절처리 & 파일 다운로드</button>
    </div>
    <div class="side-area">
      <h3>선택된 품절 옵션</h3>
      <ul id="soldoutList">
        <li style="color:#b5b5b5;">(선택내역 없음)</li>
      </ul>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script>
    
    // === Global state (필수) ===
let fileList = [];
let fileDataArr = [];
let allRows = [];
let uniqueCodes = [];
let soldoutState = {};
let optionMode = false;
let selectedCode = null;

// === 다운로드 직전 검증 ===
function buildValidationReport() {
  const r = {
    missingCode: [],
    parseFail: [],
    duplicates: [],
    mixedSizePattern: [],
    totals: { rows: allRows.length }
  };

  const dupMap = new Map();                     // key -> {count, samples}
  const mixMap = new Map();                     // (file||code) -> {hasSlash, hasPlain}
  const sizeSlashRe = /^([A-Za-z0-9]+)\s*\/\s*.+$/;

  allRows.forEach((row, i) => {
    const code = row['관리코드'] || row['상품코드'] || row['코드'] || '';
    if (!code) r.missingCode.push(i);

    const { color, size } = extractColorAndSize(row);
    const label = (row['제품선택'] || row['추가상품값'] || '').toString().trim();
    if (!color && !size && !label) r.parseFail.push(i);

    const k = `${row.file}||${code}||${color}||${size}`;
    if (!dupMap.has(k)) dupMap.set(k, { count: 0, samples: [] });
    const d = dupMap.get(k);
    d.count++;
    if (d.samples.length < 5) d.samples.push(i);

    const bucket = `${row.file}||${code}`;
    const v = (row['사이즈'] ?? '').toString().trim();
    if (v) {
      if (!mixMap.has(bucket)) mixMap.set(bucket, { hasSlash: false, hasPlain: false });
      const cur = mixMap.get(bucket);
      if (sizeSlashRe.test(v)) cur.hasSlash = true; else cur.hasPlain = true;
    }
  });

  dupMap.forEach((v, key) => { if (v.count > 1) r.duplicates.push({ key, count: v.count, samples: v.samples }); });

  mixMap.forEach((v, bucket) => {
    if (v.hasSlash && v.hasPlain) {
      const [file, code] = bucket.split('||');
      r.mixedSizePattern.push({ file, code, detail: '사이즈 열에 접미사 패턴과 순수값이 혼재' });
    }
  });

  r.totals.issues =
    r.missingCode.length + r.parseFail.length + r.duplicates.length + r.mixedSizePattern.length;

  return r;
}

function formatValidationSummary(report) {
  if (!report || !report.totals) return '검증 결과를 생성하지 못했습니다.';
  const lines = [];
  lines.push(`총 행: ${report.totals.rows.toLocaleString()}개`);
  lines.push(`- 관리코드 누락: ${report.missingCode.length}개`);
  lines.push(`- 색상/사이즈 파싱 실패: ${report.parseFail.length}개`);
  lines.push(`- 중복 옵션 키: ${report.duplicates.length}개 그룹`);
  lines.push(`- 혼재된 사이즈 표기: ${report.mixedSizePattern.length}개 그룹`);

  if (report.duplicates.length) {
    const s = report.duplicates.slice(0, 3).map(d => {
      const [file, code, color, size] = d.key.split('||');
      return `  • (${d.count}회) [${file}] ${code} / ${color || '-'} / ${size || '-'}`;
    });
    lines.push('중복 예시:'); lines.push(...s);
  }
  if (report.mixedSizePattern.length) {
    const s = report.mixedSizePattern.slice(0, 3).map(m => `  • [${m.file}] ${m.code} — ${m.detail}`);
    lines.push('혼재 예시:'); lines.push(...s);
  }
  lines.push('');
  lines.push('내려받기를 계속하시겠어요?');
  return lines.join('\n');
}


// id 안전치환 (버튼/팝업 id 만들 때 사용)
function toSafeId(str) {
  return String(str).replace(/[^a-zA-Z0-9\-_:.]/g, '_');
}

// 행에서 색상/사이즈 추출 (컬럼/라벨/패턴 모두 대응)
function extractColorAndSize(row) {
  let color = (row['색상']  ?? '').toString().trim();
  let size  = (row['사이즈'] ?? '').toString().trim();
  const label = (row['제품선택'] || row['추가상품값'] || '').toString().trim();
  const tokens = label ? label.split('/').map(s => s.trim()).filter(Boolean) : [];

  // Case B: 색상열이 "NN / 접미사"이면 NN을 사이즈로 인식
  const m = color.match(/^([A-Za-z0-9]+)\s*\/\s*(.+)$/);
  if (!size && m && isSizeToken(m[1])) {
    size = m[1].trim();
    // 실제 색상은 라벨의 마지막 '사이즈가 아닌' 토큰으로 추정
    for (let i = tokens.length - 1; i >= 0; i--) {
      if (!isSizeToken(tokens[i])) { color = tokens[i]; break; }
    }
  }

  // 보강: 여전히 size가 없으면 라벨에서 마지막 사이즈 토큰
  if (!size && tokens.length) {
    for (let i = tokens.length - 1; i >= 0; i--) {
      if (isSizeToken(tokens[i])) { size = tokens[i]; break; }
    }
  }
  // 보강: 여전히 color가 없으면 라벨의 마지막 비-사이즈 토큰
  if (!color && tokens.length) {
    for (let i = tokens.length - 1; i >= 0; i--) {
      if (!isSizeToken(tokens[i])) { color = tokens[i]; break; }
    }
  }

  if (size && size.includes('/')) size = size.split('/')[0].trim();
  return { color: color || '', size: size || '' };
}


// 사이즈 토큰 판단 & 정렬 도우미 (이미 있으면 중복 추가 X)
function isSizeToken(v){
  return /^(FREE|XS|S|M|L|XL|XXL|\d{2,3})$/i.test(String(v||'').trim());
}
const SIZE_ORDER = ['FREE','XS','S','M','L','XL','XXL'];
function sizeKey(v){
  const u = String(v||'').toUpperCase().trim();
  const idx = SIZE_ORDER.indexOf(u);
  if (idx !== -1) return {t:0, v:idx};
  const n = parseInt(u,10);
  if (!Number.isNaN(n)) return {t:1, v:n};
  return {t:2, v:u};
}
function compareSize(a,b){
  const ka = sizeKey(a), kb = sizeKey(b);
  if (ka.t !== kb.t) return ka.t - kb.t;
  if (ka.v < kb.v) return -1;
  if (ka.v > kb.v) return 1;
  return 0;
}

// 라벨 → 토큰
function labelToTokens(rowOrLabel){
  const raw = typeof rowOrLabel === 'string'
    ? rowOrLabel
    : (rowOrLabel['제품선택'] || rowOrLabel['추가상품값'] || '').toString();
  return raw.split('/').map(s => s.trim()).filter(Boolean);
}

// (파일+관리코드) 기준: 라벨이 "색상"을 포함하는 형식인지
function labelHasColorForCodeInFile(code, file){
  const rows = allRows.filter(r => r.file === file && r.관리코드 === code);

  // 이 코드/파일에 실제로 존재하는 '색상 후보'를 모두 수집
  const colorSetUpper = new Set(
    rows.map(r => (r['색상'] || extractColorAndSize(r).color || '')
          .toString().trim())
        .filter(Boolean)
        .map(c => c.toUpperCase())
  );
  if (colorSetUpper.size === 0) return false;

  // 라벨 토큰에 위 색상 후보 중 하나라도 있으면 "라벨에 색상 있음"
  return rows.some(r => {
    const toks = labelToTokens(r).map(t => t.toUpperCase());
    for (const C of colorSetUpper) if (toks.includes(C)) return true;
    return false;
  });
}


// 상품명 뒤에 색상 삽입 (해당 코드에서 쓰는 색상 토큰들 제거 후 삽입)
function buildLabelInsertColorAfterProductForCodeFile(code, file, tplRow, newColor){
  const tokens = labelToTokens(tplRow);

  // 이 코드/파일의 모든 색상 후보를 '컬럼' + '라벨 추출' 양쪽에서 모아 세트화
  const colorSetUpper = new Set(
    allRows
      .filter(r => r.file === file && r.관리코드 === code)
      .map(r => {
        let c = (r['색상'] || '').toString().trim();
        if (!c) {
          // 색상 컬럼이 비어 있으면 라벨에서 추출
          const ex = extractColorAndSize(r);
          c = ex.color || '';
        }
        return c;
      })
      .filter(Boolean)
      .map(c => c.toUpperCase())
  );

  // 기존 라벨에서 '이미 쓰인 색상 토큰'과 '사이즈 토큰'을 제거
  const filtered = tokens.filter(t => {
    const T = t.toUpperCase();
    return !colorSetUpper.has(T) && !isSizeToken(t);
  });

  // 제품명 뒤(첫 토큰 뒤)에 새 색상 삽입
  const out = [...filtered.slice(0,1), newColor, ...filtered.slice(1)];
  return out.filter(Boolean).join(' / ');
}


// 라벨의 마지막 '사이즈 같은 토큰'만 교체 (접미사 보존)
function replaceLastSizeTokenInLabel(labelStr, newSize){
  const tokens = labelStr.split('/').map(s => s.trim()).filter(Boolean);
  for (let i = tokens.length - 1; i >= 0; i--){
    if (isSizeToken(tokens[i])) { tokens[i] = newSize; return tokens.join(' / '); }
  }
  return [newSize, ...tokens].join(' / ');
}

function detectSizeDisplayPatternForCodeFile(code, file) {
  const rows = allRows.filter(r => r.file===file && r.관리코드===code);

  // [사이즈 열이 "NN / 접미사" 패턴]
  for (const r of rows) {
    const v = (r['사이즈'] ?? '').toString().trim();
    const m = v.match(/^([A-Za-z0-9]+)\s*\/\s*(.+)$/);
    if (m && isSizeToken(m[1])) {
      const suf = m[2].trim();
      return {
        column: '사이즈',
        suffix: suf,
        format: val => `${val} / ${suf}`,                // ← 기록할 때 접미사 붙이기
        parse:  row => {
          const vv = (row['사이즈'] ?? '').toString().trim();
          const mm = vv.match(/^([A-Za-z0-9]+)\s*\/\s*(.+)$/);
          return mm ? mm[1].trim() : vv;                // ← 비교/정렬은 숫자만
        }
      };
    }
  }

  // [사이즈 열이 순수 값]
  for (const r of rows) {
    const v = (r['사이즈'] ?? '').toString().trim();
    if (v) {
      return {
        column: '사이즈',
        suffix: '',
        format: val => val,
        parse:  row => (row['사이즈'] ?? '').toString().trim()
      };
    }
  }

  // [색상 열이 "NN / 접미사" 패턴]
  for (const r of rows) {
    const v = (r['색상'] ?? '').toString().trim();
    const m = v.match(/^([A-Za-z0-9]+)\s*\/\s*(.+)$/);
    if (m && isSizeToken(m[1])) {
      const suf = m[2].trim();
      return {
        column: '색상',
        suffix: suf,
        format: val => `${val} / ${suf}`,
        parse:  row => {
          const vv = (row['색상'] ?? '').toString().trim();
          const mm = vv.match(/^([A-Za-z0-9]+)\s*\/\s*(.+)$/);
          return mm ? mm[1].trim() : '';
        }
      };
    }
  }

  return { column: null, suffix: '', format: v => v, parse: () => '' };
}


// 해당 행이 지정 색상인지 판단 (패턴 고려)
function rowHasColorWithPattern(row, color, pattern){
  const label = (row['제품선택'] || row['추가상품값'] || '').toString();
  const tokens = label.split('/').map(s=>s.trim());
  if (tokens.some(t => t === color)) return true;
  if (pattern.column !== '색상') {
    const ccol = (row['색상'] ?? '').toString().trim();
    if (ccol && ccol === color) return true;
  }
  return false;
}

// 같은 파일+코드+색상 블록을 사이즈 오름차순으로 재정렬
function reorderColorBlock(file, code, color, pattern){
  const list = [];
  for (let i=0;i<allRows.length;i++){
    const r = allRows[i];
    if (r.file===file && r.관리코드===code && rowHasColorWithPattern(r, color, pattern)){
      list.push({idx:i, row:r});
    }
  }
  if (list.length <= 1) return;

  const baseStart = Math.min(...list.map(o=>o.idx));
  const sortedRows = list.map(o=>o.row).sort((a,b)=>{
    const sa = pattern.parse(a);
    const sb = pattern.parse(b);
    return compareSize(sa, sb);
  });

  const removeIdx = new Set(list.map(o=>o.idx));
  const kept = [];
  for (let i=0;i<allRows.length;i++){
    if (!removeIdx.has(i)) kept.push(allRows[i]);
  }
  kept.splice(baseStart, 0, ...sortedRows);
  allRows = kept;
}

// ▼ 모드 상태: 'soldout' | 'edit'
let mode = 'soldout';

document.getElementById('inputFiles').addEventListener('change', async function(e) { await handleFiles(e.target.files); });
document.getElementById('resetBtn').addEventListener('click', resetAll);
document.getElementById('toggleOptionModeBtn').addEventListener('click', function(){
  optionMode = !optionMode;
  this.textContent = optionMode ? '색상,사이즈별 품절 ON' : '색상,사이즈별 품절 OFF';
  if(optionMode) this.classList.add('on');
  else this.classList.remove('on');
  selectedCode = null;
  updateCodeBtns();
});

// 상단 모드 스위치 버튼
const modeSoldoutBtn = document.getElementById('modeSoldoutBtn');
const modeEditBtn    = document.getElementById('modeEditBtn');

modeSoldoutBtn.addEventListener('click', () => {
  if (mode === 'soldout') return;
  mode = 'soldout';
  modeSoldoutBtn.classList.add('on');
  modeEditBtn.classList.remove('on');

  // 필요하면 편집 모드에서 비활성화했던 토글 되살리기
  const tBtn = document.getElementById('toggleOptionModeBtn');
  tBtn.disabled = false; // 선택사항

  selectedCode = null;
  updateCodeBtns();
});

modeEditBtn.addEventListener('click', () => {
  if (mode === 'edit') return;
  mode = 'edit';
  modeEditBtn.classList.add('on');
  modeSoldoutBtn.classList.remove('on');

  optionMode = true;
  const tBtn = document.getElementById('toggleOptionModeBtn');
  tBtn.classList.add('on');
  tBtn.textContent = '색상,사이즈별 품절 ON';
  tBtn.disabled = true; // 선택사항: 편집 모드에서는 토글 못 누르게

  selectedCode = null;
  updateCodeBtns();
});



function resetAll() {
  fileList = []; fileDataArr = []; allRows = []; uniqueCodes = []; soldoutState = {}; selectedCode = null;
  document.getElementById('fileNames').textContent = '';
  document.getElementById('fileCount').textContent = '';
  document.getElementById('inputFiles').value = '';
  document.getElementById('prodCountInfo').textContent = '';
  document.getElementById('codeBtnArea').innerHTML = '';
  updateSoldoutList();
  document.getElementById('downloadBtn').disabled = true;
}

async function handleFiles(filelist) {
  if (!filelist || filelist.length === 0) return;
  for (let file of filelist) {
    if (fileList.find(f=>f.name===file.name)) continue;
    fileList.push(file);
    let data = await readExcel(file);
    fileDataArr.push({name: file.name, data});
  }
  mergeAllRows();
  updateCodeBtns();
  updateProdCount();
  updateSoldoutList();
  let names = fileList.map(f=>f.name).join(', ');
  let fileNamesElem = document.getElementById('fileNames');
  if (names.length > 45) {
    let split = names.split(',');
    let shown = split.slice(0,2).join(', ') + ' ...';
    fileNamesElem.textContent = shown;
  } else {
    fileNamesElem.textContent = names;
  }
  document.getElementById('fileCount').textContent = fileList.length > 1 ? `+${fileList.length}개` : '';
  document.getElementById('downloadBtn').disabled = false;
}

function readExcel(file) {
  return new Promise(resolve => {
    const reader = new FileReader();
    reader.onload = e => {
      const data = new Uint8Array(e.target.result);
      const wb = XLSX.read(data, {type:'array'});
      const ws = wb.Sheets[wb.SheetNames[0]];
      let json = XLSX.utils.sheet_to_json(ws, {defval:""});
      resolve(json);
    };
    reader.readAsArrayBuffer(file);
  });
}

function mergeAllRows() {
  allRows = [];
  let codeSet = new Set();
  for (let {name, data} of fileDataArr) {
    data.forEach(row => {
      const code = row['관리코드'] || row['상품코드'] || row['코드'] || '';
      allRows.push({
        ...row,
        file: name,
        관리코드: code,
        _normCode: normCode(code)        // ★ 추가: 정규화된 코드
      });
      if (code) codeSet.add(code);

      if (typeof code === 'string' && code.trim().startsWith('단종')) {
        soldoutState[code] = { 전체: "discont", 복합: [] };
      }
    });
  }
  uniqueCodes = Array.from(codeSet);
}


function updateCodeBtns() {
  const area = document.getElementById('codeBtnArea');
  area.innerHTML = '';
  for (let code of uniqueCodes) {
    if (!code) continue;
    const wrap = document.createElement('div');
    wrap.className = 'code-btn-wrap';
    const btn = document.createElement('button');
    btn.id = 'codeBtn_' + toSafeId(code);
    btn.className = 'code-btn'; // 항상 초기화

    // 상태 class 1개만!
if (soldoutState[code]?.전체 === "discont") {
  btn.classList.add('discont');
} else if (soldoutState[code]?.전체 === "soldout") {
  btn.classList.add('selected');
} else if ((soldoutState[code]?.복합 || []).length > 0) {
  btn.classList.add('has-soldout');
}



    // 선택된(팝업 오픈) 버튼은 boxShadow로만 강조, class 추가 X
    if (selectedCode === code) btn.style.boxShadow = '0 0 0 2px #b5e9d6 inset';
    else btn.style.boxShadow = '';

    btn.textContent = code;
    btn.onclick = (e) => {
      e.stopPropagation();
      if (optionMode) {
        selectedCode = code;
        updateCodeBtns();
      } else {
        if (!soldoutState[code] || !soldoutState[code].전체) {
          soldoutState[code] = { 전체: "soldout", 복합: [] };
        } else if (soldoutState[code].전체 === "soldout") {
          soldoutState[code].전체 = "discont";
        } else if (soldoutState[code].전체 === "discont") {
          soldoutState[code] = { 전체: false, 복합: [] };
        }
        selectedCode = null;
        updateCodeBtns();
        updateSoldoutList();
      }
    };

    wrap.appendChild(btn);

if (optionMode && selectedCode === code) {
  const rows = rowsByCode(code);
  let colorSet = new Set(), sizeSet = new Set();
  rows.forEach(r => {
    const { color, size } = extractColorAndSize(r);
    if (color && color !== "") colorSet.add(color);
    if (size && size !== "")  sizeSet.add(size);
  });
  const colors = Array.from(colorSet).filter(x => x !== "");
  const sizes  = Array.from(sizeSet).filter(x => x !== "");

  if (mode === 'soldout') {
    if (colors.length > 0 || sizes.length > 0) {
      showOptionSelect(code, wrap, colors, sizes);
    }
  } else {
    showOptionSelectForEdit(code, wrap, colors, sizes);
  }
}


    area.appendChild(wrap);
  }
  document.body.onclick = function() {
    if (selectedCode !== null) {
      selectedCode = null;
      updateCodeBtns();
    }
  }
}


function showOptionSelect(code, wrapElem, colors, sizes) {
  // 기존 팝업 DOM 제거
  Array.from(wrapElem.querySelectorAll('.option-select-area.popup')).forEach(el => el.remove());

  let box = document.createElement('div');
  box.id = 'optionBox_' + toSafeId(code);
  box.className = 'option-select-area popup';
  box.innerHTML = `
    <div style="margin-bottom:5px;font-weight:500;font-size:13.3px;color:#2b7365">
      품절로 처리할 색상/사이즈 옵션을 선택하세요.
    </div>
    <div id="optionBtnArea_${toSafeId(code)}"></div>
    <button class="option-soldout-area" style="width:100%;" onclick="event.stopPropagation();hideOptionSelect('${code}')">닫기</button>
  `;
  setTimeout(() => {

    let optArea = box.querySelector('#optionBtnArea_' + toSafeId(code));
    if (!optArea) return;
    const grid = document.createElement('div');
    grid.className = 'option-btn-grid';

    // 관리코드 전체 상태
    const 전체상태 = soldoutState[code]?.전체;
    const isAllSoldout = 전체상태 === "soldout";
    const isAllDiscont = 전체상태 === "discont";

    // 옵션별 상태 추출 함수
    function getBtnClass(opt) {
      if (!opt) return '';
      if (opt.상태 === "discont") return 'discont';
      if (opt.상태 === "soldout") return 'selected';
      return '';
    }
      // 팝업 내부 버튼들의 표시 상태를 soldoutState 기준으로 리프레시
  function refreshPopup() {
    const 전체상태 = soldoutState[code]?.전체;
    const isAllSoldout = 전체상태 === "soldout";
    const isAllDiscont = 전체상태 === "discont";

    grid.querySelectorAll('.option-btn').forEach(btn => {
      const c = (btn.dataset.color || '').trim();
      const s = (btn.dataset.size  || '').trim();
      btn.classList.remove('selected','discont');

      if (isAllSoldout) { btn.classList.add('selected'); return; }
      if (isAllDiscont) { btn.classList.add('discont');  return; }

      const st = getState(code, c || null, s || null);
      if (st?.상태 === 'soldout') btn.classList.add('selected');
      if (st?.상태 === 'discont') btn.classList.add('discont');
    });
  }


    function getState(code, color, size) {
      const arr = soldoutState[code]?.복합 || [];
      const nc = (color ?? '').trim();
      const ns = (size  ?? '').trim();
      return arr.find(o => (o.색상 ?? '').trim() === nc && (o.사이즈 ?? '').trim() === ns);
    }

    // 옵션 버튼 생성
function createOptionBtn(color, size, label) {
  const b = document.createElement('button');
  b.className = 'option-btn';
  b.textContent = label;
  b.dataset.color = color || '';
  b.dataset.size  = size  || '';

  // 초기 상태 도색
  let opt = getState(code, color, size);
  let btnClass = getBtnClass(opt);
  if (isAllSoldout) b.classList.add('selected');
  else if (isAllDiscont) b.classList.add('discont');
  else if (btnClass) b.classList.add(btnClass);

  b.onclick = (e) => {
    e.stopPropagation();
    soldoutState[code] = soldoutState[code] || { 전체: false, 복합: [] };

    // 전체 상태였으면 해제(개별로 전환)
    if (soldoutState[code].전체 === "soldout" || soldoutState[code].전체 === "discont") {
      soldoutState[code].전체 = false;
    }

    // 옵션별 상태 순환: 품절 → 단종 → 해제
    let idx = (soldoutState[code].복합 || []).findIndex(o =>
      (o.색상 === color || (!color && !o.색상)) &&
      (o.사이즈 === size || (!size && !o.사이즈))
    );

    if (idx < 0) {
      soldoutState[code].복합.push(
        color && size ? { 색상: color, 사이즈: size, 상태: "soldout" }
        : color ?      { 색상: color, 상태: "soldout" }
                 :      { 사이즈: size, 상태: "soldout" }
      );
    } else if (soldoutState[code].복합[idx].상태 === "soldout") {
      soldoutState[code].복합[idx].상태 = "discont";
    } else {
      soldoutState[code].복합.splice(idx, 1);
    }

    // 전체 승격 여부 계산 (전부 단종/전부 품절)
    checkAndAutoSetAllOptionState(code);

    // 팝업은 그대로, 표시만 갱신
    refreshPopup();

    // 사이드 리스트는 즉시 반영
    updateSoldoutList();
  };

  grid.appendChild(b);
}


    // 색상+사이즈
    if (colors.length && sizes.length) {
      for (let color of colors) {
        for (let size of sizes) {
          createOptionBtn(color, size, `${color} / ${size}`);
        }
      }
    } else if (colors.length) {
      colors.forEach(color => {
        createOptionBtn(color, '', color);   // 사이즈는 ''로 고정
      });
    } else if (sizes.length) {
     sizes.forEach(size => {
        createOptionBtn('', size, size);     // 색상은 ''로 고정
      });
    }

    optArea.appendChild(grid);
  }, 0);
  wrapElem.appendChild(box);
  box.onclick = function(e){ e.stopPropagation(); };
}



// updateSoldoutList 함수 전체 교체!
function updateSoldoutList() {
  const ul = document.getElementById('soldoutList');
  ul.innerHTML = '';
  let any = false;
  for (let code of uniqueCodes) {
    if (soldoutState[code]?.전체 === "discont") {
      ul.innerHTML += `<li><b>${code}</b> <span style="color:#533e8e;font-weight:700;">전체단종</span></li>`;
      any = true;
    } else if (soldoutState[code]?.전체 === "soldout") {
      ul.innerHTML += `<li><b>${code}</b> <span style="color:#606060;font-weight:700;">전체품절</span></li>`;
      any = true;
    } else if ((soldoutState[code]?.복합||[]).length > 0) {
      for (let opt of soldoutState[code].복합) {
        let stateLabel = opt.상태 === "discont" ? '<span style="color:#533e8e;font-weight:700;">단종</span>' : '품절';
        ul.innerHTML += `<li><b>${code}</b> ${opt.색상?opt.색상+'/':''}${opt.사이즈||''} ${stateLabel}</li>`;
        any = true;
      }
    }
  }
  if (!any) ul.innerHTML = `<li style="color:#b5b5b5;">(선택내역 없음)</li>`;
}


document.getElementById('downloadBtn').addEventListener('click', async function () {
  // 1) 검증 요약 표시
  const report = buildValidationReport();
  const msg = formatValidationSummary(report);
  if (report.totals.issues > 0) {
    if (!confirm(msg)) return; // 사용자가 취소하면 중단
  }

  // 2) 준비
  const fillStock = document.getElementById('fillStockCheckbox').checked;
  if (typeof JSZip === 'undefined') {
    alert('JSZip 로드에 실패했습니다. 인터넷 연결/스크립트 경로를 확인하세요.');
    return;
  }
  const zip = new JSZip();

  // 3) 관리코드별 옵션 현황 계산
  const codeOptionCount = {};
  for (const row of allRows) {
    const code = row['관리코드'] || row['상품코드'] || row['코드'] || '';
    if (!code) continue;
    codeOptionCount[code] ??= { total: 0, soldout: 0, discont: 0 };
    codeOptionCount[code].total++;

    const target = soldoutState[code];
    let isSoldout = false, isDiscont = false;

    if ((target?.복합 || []).length > 0) {
      const { color, size } = extractColorAndSize(row);
      for (const opt of target.복합) {
        const matchColor = (!opt.색상 || color === opt.색상);
        const matchSize  = (!opt.사이즈 || size  === opt.사이즈);
        if (matchColor && matchSize) {
          if (opt.상태 === 'discont') isDiscont = true;
          if (opt.상태 === 'soldout') isSoldout = true;
        }
      }
    }
    if (target?.전체 === 'discont') isDiscont = true;
    else if (target?.전체 === 'soldout') isSoldout = true;

    if (isDiscont) codeOptionCount[code].discont++;
    else if (isSoldout) codeOptionCount[code].soldout++;
  }

  // 4) 전부 품절/단종 → 전체 상태 승격
  for (const code in codeOptionCount) {
    const stat = codeOptionCount[code];
    if (stat.discont === stat.total) {
      soldoutState[code] ??= { 전체: false, 복합: [] };
      soldoutState[code].전체 = 'discont';
      soldoutState[code].복합 = [];
    } else if (stat.soldout + stat.discont === stat.total) {
      soldoutState[code] ??= { 전체: false, 복합: [] };
      if (soldoutState[code].전체 !== 'discont') {
        soldoutState[code].전체 = 'soldout';
        soldoutState[code].복합 = [];
      }
    }
  }

  // 5) 파일별로 시트 생성해서 ZIP에 담기
  const rowsByFile = {};
  for (const r of allRows) {
    const fname = r.file || '편집추가.xlsx';
    (rowsByFile[fname] ??= []).push(r);
  }

  for (const name in rowsByFile) {
    const data = rowsByFile[name];
    const newData = data.map(row => {
      const codeKey = getCodeKey(row);
      const code = codeKey ? row[codeKey] : '';
      const target = soldoutState[code];

      let isSoldout = false, isDiscont = false;
      if ((target?.복합 || []).length > 0) {
        const { color, size } = extractColorAndSize(row);
        for (const opt of target.복합) {
          const matchColor = (!opt.색상 || color === opt.색상);
          const matchSize  = (!opt.사이즈 || size  === opt.사이즈);
          if (matchColor && matchSize) {
            if (opt.상태 === 'discont') isDiscont = true;
            if (opt.상태 === 'soldout') isSoldout = true;
          }
        }
      }
      if (target?.전체 === 'discont') isDiscont = true;
      else if (target?.전체 === 'soldout') isSoldout = true;

      const rowCopy = { ...row };
      if (isDiscont) {
        if (codeKey) rowCopy[codeKey] = makeDiscontCode(rowCopy[codeKey]);
        rowCopy['재고수량'] = 0;
      } else if (isSoldout || String(code || '').trim().startsWith('단종')) {
        if (String(code || '').trim().startsWith('단종') && codeKey) {
          rowCopy[codeKey] = makeDiscontCode(rowCopy[codeKey]);
        }
        rowCopy['재고수량'] = 0;
      } else if (fillStock && (!rowCopy['재고수량'] || rowCopy['재고수량'] == 0)) {
        rowCopy['재고수량'] = 99999;
      }

      delete rowCopy.file;
      delete rowCopy._normCode;   // ← 이 줄 추가!
      return rowCopy;
    });

    const ws = XLSX.utils.json_to_sheet(newData);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
    const xlsBlob = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });

    const outName = name.endsWith('.xlsx') ? name : name.replace(/\.xls$/i, '.xlsx');
    zip.file(outName, xlsBlob);
  }

  // 6) ZIP 다운로드
  const blob = await zip.generateAsync({ type: 'blob' });
  saveAs(blob, '품절처리_일괄다운로드.zip');
});


function updateProdCount() {
  document.getElementById('prodCountInfo').textContent = uniqueCodes.length
    ? `총 ${uniqueCodes.length}개 선택됨` : '';
}

const fileDropZone = document.getElementById('fileDropZone');
fileDropZone.addEventListener('dragover', function(e) {
  e.preventDefault();
  e.stopPropagation();
  fileDropZone.classList.add('dragover');
});
fileDropZone.addEventListener('dragleave', function(e) {
  e.preventDefault();
  e.stopPropagation();
  fileDropZone.classList.remove('dragover');
});
fileDropZone.addEventListener('drop', function(e) {
  e.preventDefault();
  e.stopPropagation();
  fileDropZone.classList.remove('dragover');
  const files = e.dataTransfer.files;
  if (files.length) {
    handleFiles(files);
  }
});
function checkAndAutoSetAllOptionState(code) {
  // 대상 관리코드 행 모으기
const rows = rowsByCode(code);
  const totalCnt = rows.length;
  let soldoutCnt = 0, discontCnt = 0;

  // 상태 컨테이너 보정
  soldoutState[code] = soldoutState[code] || { 전체: false, 복합: [] };

  // 와일드카드 매칭: 옵션에 저장된 색상/사이즈가 '' 이면 그 축은 모두 매칭
  const isMatch = (opt, color, size) => {
    const oc = (opt.색상 ?? '').trim();
    const os = (opt.사이즈 ?? '').trim();
    const rc = (color ?? '').trim();
    const rs = (size  ?? '').trim();
    const colorOK = (oc === '' || oc === rc);
    const sizeOK  = (os === '' || os === rs);
    return colorOK && sizeOK;
  };

  // 각 행 상태 집계
  for (const r of rows) {
    const { color, size } = extractColorAndSize(r);
    const match = (soldoutState[code].복합 || []).find(o => isMatch(o, color, size));
    if (match) {
      if (match.상태 === 'discont') discontCnt++;
      else if (match.상태 === 'soldout') soldoutCnt++;
    }
  }

  // 승격: 전부 단종 → 전체단종 / 전부 품절 → 전체품절 / 혼합이면 승격 안 함
  if (totalCnt > 0 && discontCnt === totalCnt) {
    soldoutState[code].전체 = 'discont';
    soldoutState[code].복합 = [];
  } else if (totalCnt > 0 && soldoutCnt === totalCnt) {
    soldoutState[code].전체 = 'soldout';
    soldoutState[code].복합 = [];
  } else {
    soldoutState[code].전체 = false;
  }

  // 사이드 리스트만 갱신 (코드버튼 전체 리렌더는 팝업 클릭 중엔 금지)
  updateSoldoutList();

}

function hideOptionSelect(code) {
  let box = document.getElementById('optionBox_' + toSafeId(code));
  if (box) box.remove();
  selectedCode = null;
  updateCodeBtns();
}

// REPLACE: showOptionSelectForEdit
function showOptionSelectForEdit(code, wrapElem, colors, sizes) {
  // 같은 코드의 기존 편집 팝업 제거
  Array.from(wrapElem.querySelectorAll('.option-select-area.popup')).forEach(el => el.remove());

  // ✅ 이 함수 내부에서 '해당 코드' 행만 다시 필터링 (다른 코드 섞임 방지)
  const rowsOnlyThisCode = rowsByCode(code);

  // 템플릿/컬럼 유무 결정도 오직 이 코드에서만
  const template = rowsOnlyThisCode[0] || {};
  const hasSizeCol = Object.prototype.hasOwnProperty.call(template, '사이즈');

  // (안전) 색상/사이즈 목록도 이 코드 행들에서 다시 추출
  const colorSet = new Set();
  const sizeSet  = new Set();
  rowsOnlyThisCode.forEach(r => {
    const { color, size } = extractColorAndSize(r);
    if (color) colorSet.add(color.trim());
    if (size)  sizeSet.add(size.trim());
  });
  const colorsSafe = Array.from(colorSet);
  const sizesSafe  = Array.from(sizeSet);

  // 팝업 DOM
  const box = document.createElement('div');
  box.id = 'editOptionBox_' + toSafeId(code);
  box.className = 'option-select-area popup';
  box.style.minWidth = '380px';
  box.innerHTML = `
    <div style="margin-bottom:8px;font-weight:600;font-size:14px;color:#2b7365">
      옵션 편집 모드 – <span style="color:#146f58">${code}</span>
    </div>

    <!-- 신규 옵션 추가 -->
    <div style="padding:8px;border:1px solid #cfe3d8;border-radius:8px;margin-bottom:10px;">
      <div style="font-size:12px;color:#547a6b;margin-bottom:6px;">새 옵션 추가</div>

      <div style="display:flex;gap:6px;margin-bottom:6px;">
        <input type="text" id="newColor_${code}" placeholder="색상" style="flex:1;padding:4px;font-size:12px;">
        <input type="text" id="newSize_${code}" placeholder="${hasSizeCol ? '사이즈' : '사이즈 열 없음'}"
               ${hasSizeCol ? '' : 'disabled'} style="flex:1;padding:4px;font-size:12px;">
      </div>

      <div style="display:flex;gap:6px;margin-bottom:8px;">
        <input type="number" id="newStock_${code}" placeholder="재고수량(기본: 99999)"
               value="99999" style="flex:1;padding:4px;font-size:12px;">
      </div>

      <button id="addBtn_${code}"
        style="width:100%;padding:6px;font-size:13px;background:#2b7365;color:#fff;border:none;border-radius:4px;cursor:pointer;">
        + 추가
      </button>

      <div style="margin-top:6px;font-size:11px;color:#7a8d84;line-height:1.4;">
        • 색상만 입력하면 → 해당 코드의 <b>모든 기존 사이즈</b>로 일괄 추가<br>
        • 사이즈만 입력하면 → 해당 코드의 <b>모든 기존 색상</b>으로 일괄 추가<br>
        • 색상+사이즈 모두 입력 → 해당 조합 1개 추가/갱신<br>
        • 재고수량 미입력 시 기본 99999 적용
      </div>
    </div>

    <!-- 기존 옵션 목록 -->
    <div style="font-size:12px;color:#547a6b;margin-bottom:4px;">현재 옵션 목록</div>
    <div id="optionList_${code}" style="display:flex;flex-direction:column;gap:4px;max-height:220px;overflow:auto;">
      ${renderOptionListHTML(code)}
    </div>

    <button class="option-soldout-area" style="width:100%;margin-top:8px;"
            onclick="event.stopPropagation();hideOptionSelect('${code}')">닫기</button>
  `;

  wrapElem.appendChild(box);
  box.onclick = (e) => e.stopPropagation();

  // 추가 버튼 이벤트
  const addBtn = box.querySelector(`#addBtn_${cssEscapeId(code)}`) || box.querySelector(`#addBtn_${code}`);
  if (addBtn) {
    addBtn.onclick = (e) => {
      e.stopPropagation();
      addNewOption(code);
      const listEl = document.getElementById(`optionList_${code}`);
      if (listEl) listEl.innerHTML = renderOptionListHTML(code);
    };
  }
}


// 내부에서 id 선택 시 특수문자 이슈를 줄이기 위한 보조 함수 (안전하지 않은 코드값 대비)
function cssEscapeId(raw) {
  // 간단 escape: 공백/특수문자 -> 백슬래시 이스케이프
  return String(raw).replace(/([ #;?%&,.+*~\':"!^$[\]()=>|\/@])/g, '\\$1');
}


function renderOptionListHTML(code) {
  // ✅ 혹시 모를 누수 방지: 여기에서도 rowsByCode로 강제 필터
  const rowsForCode = rowsByCode(code);
  if (!rowsForCode.length) return `<div class="opt-empty">옵션이 없습니다.</div>`;
  // (나머지 기존 로직 그대로 유지)



  // 파일별 → 색상별 → 사이즈 오름차순으로 묶기
  const byFile = {};
  rowsForCode.forEach(r => {
    const ex = extractColorAndSize(r);
    const file = r.file;
    const color = (r['색상'] || ex.color || '').toString().trim() || '(색상없음)';
    const size  = (r['사이즈'] || ex.size  || '').toString().trim()  || '(사이즈없음)';
    const stock = r['재고수량'];

    byFile[file] ??= {};
    byFile[file][color] ??= [];
    byFile[file][color].push({ row: r, color, size, stock });
  });

  // 출력
  let html = '';
  Object.keys(byFile).forEach(file => {
    html += `
      <div class="opt-file">
        <div class="opt-file__title">${file}</div>
    `;
    const byColor = byFile[file];

    Object.keys(byColor).sort((a,b)=>a.localeCompare(b,'ko')).forEach(color => {
      // 사이즈 정렬
      const list = byColor[color].sort((a,b)=>compareSize(a.size, b.size));

      html += `<div class="opt-color">
        <div class="opt-color__title">${color}</div>
        <div class="opt-sizes">`;

      list.forEach(item => {
        const zero = Number(item.stock) === 0;
        html += `
          <span class="size-chip ${zero ? 'is-zero' : ''}"
                title="재고: ${item.stock}">
            ${item.size}
            <em class="size-chip__stock">${item.stock}</em>
          </span>`;
      });

      html += `</div></div>`; // .opt-sizes, .opt-color
    });

    html += `</div>`; // .opt-file
  });

  if (!html) {
    html = `<div class="opt-empty">옵션이 없습니다.</div>`;
  }
  return html;
}

function removeOption(code, color, size) {
  const key = normCode(code);
  allRows = allRows.filter(r => {
    if (r._normCode !== key) return true;
    const cs = extractColorAndSize(r);
    return !((cs.color || '') === color && (cs.size || '') === size);
  });
  document.getElementById(`optionList_${code}`).innerHTML = renderOptionListHTML(code);
}



// 템플릿 라벨의 끝 "색상/사이즈" 토큰을 지우고 새 색상만 붙이는 함수
function buildProductTextFromTemplate(tplRow, newColor) {
  const raw = (tplRow['제품선택'] || tplRow['추가상품값'] || '').toString();
  const tokens = raw.split('/').map(s => s.trim()).filter(Boolean);
  if (!tokens.length) return newColor || '';

  // 컬럼값이 비어있을 때를 대비해 라벨에서 추정
  const guess = extractColorAndSize(tplRow);
  const tplColor = (tplRow['색상']  || guess.color || '').toString().trim();
  const tplSize  = (tplRow['사이즈']|| guess.size  || '').toString().trim();

  const isSizeToken = v => /^(FREE|XS|S|M|L|XL|XXL|\d{2,3})$/i.test(v);
  const eq = (a,b) => a && b && a.toUpperCase() === b.toUpperCase();

  let cut = tokens.length;
  const last = tokens[cut - 1];
  const prev = tokens[cut - 2];

  // … / (색상) / (사이즈)
  if (cut >= 2 && (eq(last, tplSize) || isSizeToken(last)) && eq(prev, tplColor)) {
    cut -= 2;
  // … / (색상)
  } else if (cut >= 1 && eq(last, tplColor)) {
    cut -= 1;
  // … / (사이즈) 만
  } else if (cut >= 1 && isSizeToken(last)) {
    cut -= 1;
  }

  // 추가 방어: 잘라낸 뒤에도 끝이 기존 색상이면 한 번 더 제거
  let prefix = tokens.slice(0, cut);
  if (prefix.length && eq(prefix[prefix.length - 1], tplColor)) {
    prefix = prefix.slice(0, -1);
  }

  // 라벨에는 새 "색상"만 붙임 (사이즈는 컬럼에 존재하므로 라벨에 중복 금지)
  return [...prefix, (newColor || tplColor)].filter(Boolean).join(' / ');
}

function getSizesByCode(code) {
  const set = new Set();
  allRows
    .filter(r => r.관리코드 === code)
    .forEach(r => {
      const { size } = extractColorAndSize(r);
      if (size) set.add(size.trim());
    });
  return Array.from(set);
}
// 해당 관리코드의 "기존 색상" 목록을 중복 없이 반환
function getColorsByCode(code) {
  const set = new Set();
  allRows
    .filter(r => r.관리코드 === code)
    .forEach(r => {
      const { color } = extractColorAndSize(r);
      if (color) set.add(color.trim());
    });
  return Array.from(set);
}
// 라벨(제품선택/추가상품값)에서 끝의 [사이즈]와 [색상]을 지우고 새 색상만 붙임
function buildProductTextFromTemplateForCode(code, tplRow, newColor) {
  const raw = (tplRow['제품선택'] || tplRow['추가상품값'] || '').toString();
  const tokens = raw.split('/').map(s => s.trim()).filter(Boolean);

  const isSize = v => /^(FREE|XS|S|M|L|XL|XXL|\d{2,3})$/i.test(v);
  const colorSet = new Set(getColorsByCode(code).map(c => c.toUpperCase()));

  // 1) 끝이 사이즈면 제거
  if (tokens.length && isSize(tokens[tokens.length - 1])) tokens.pop();
  // 2) 끝이 '이 코드에서 쓰는 색상'이면 제거
  if (tokens.length && colorSet.has(tokens[tokens.length - 1].toUpperCase())) tokens.pop();

  tokens.push(newColor);
  return tokens.join(' / ');
}

// 행 안에서 실제 코드 컬럼 키 찾기(관리코드/상품코드/코드 중 존재하는 것)
function getCodeKey(row) {
  const norm = s => String(s).replace(/\s/g, '').toLowerCase();
  const keys = Object.keys(row || {});
  const find = want => keys.find(k => norm(k) === norm(want));
  return find('관리코드') || find('상품코드') || find('코드') || null;
}

// 행들을 "실제 코드 컬럼 값"으로 필터링
// ✅ 관리코드 비교를 완전히 안전하게(공백/대소문자/다른 컬럼 케이스 포함)
// REPLACE: rowsByCode
function rowsByCode(code) {
  const target = normCode(code);
  return allRows.filter(r => (
    normCode(r['관리코드']) === target ||
    normCode(r['상품코드']) === target ||
    normCode(r['코드'])     === target
  ));
}





// '단종 ' 프리픽스 만들기(중복 방지 + 20자 제한 유지)
function makeDiscontCode(origin) {
  let base = String(origin || '').replace(/^(단종\s*)+/g, '').trim();
  let out = '단종 ' + base;
  if (out.length > 20) {
    const compact = out.replace(/\s+/g, '');
    out = '단종' + compact.slice(2);
    if (out.length > 20) out = out.slice(0, 20);
  }
  return out;
}

// 보조: 뒤에서부터 조건에 맞는 인덱스 찾기
function findLastIndex(arr, pred){
  for (let i = arr.length - 1; i >= 0; i--) if (pred(arr[i], i, arr)) return i;
  return -1;
}

// ★ 최종 교체본: 패턴 감지 + 중복 방지 + 접미사 보존 + 색상블록 정렬
function addNewOption(code) {
  const colorInput = document.getElementById(`newColor_${code}`).value.trim();
  const sizeInput  = document.getElementById(`newSize_${code}`)?.value.trim() || '';
  const stock      = parseInt(document.getElementById(`newStock_${code}`).value.trim(), 10) || 99999;

  if (!colorInput && !sizeInput) {
    alert("색상 또는 사이즈 중 최소 하나는 입력하세요.");
    return;
  }

const listForCode = rowsByCode(code);   // 해당 관리코드 행만 필터링

// 이 코드에서 쓰인 파일만 추출
const filesForCode = Array.from(new Set(
  listForCode.map(r => r.file)
));

filesForCode.forEach(fileName => {
  // 같은 코드 + 같은 파일에서만 템플릿 찾기
  const template = listForCode.find(r => r.file === fileName);
  if (!template) return;

    // ① 이 파일+코드의 표시 규칙 감지
    const pattern = detectSizeDisplayPatternForCodeFile(code, fileName);
    const useColorInLabel = labelHasColorForCodeInFile(code, fileName);
    const useSizeInLabel  = (() => {
      const tokens = labelToTokens(template);
      return tokens.some(isSizeToken);
    })();

    // ② 추가할 색상/사이즈 집합
const colorsToUse = colorInput
  ? [colorInput]
  : (Array.from(new Set(
      allRows
        .filter(r => r.file === fileName && r.관리코드 === code)
        .map(r => {
          // 색상 필드 우선 → 없으면 라벨에서 추출
          return r['색상'] || extractColorAndSize(r).color || '';
        })
        .filter(Boolean)
    )) || ['']);


    let sizesToUse;
    if (sizeInput) sizesToUse = [sizeInput];
    else {
      const inFileRows = allRows.filter(r => r.file === fileName && r.관리코드 === code);
      const fromPattern = inFileRows.map(r => pattern.parse(r)).filter(Boolean);
      sizesToUse = fromPattern.length ? Array.from(new Set(fromPattern)) : [''];
    }
    sizesToUse = [...sizesToUse].sort(compareSize); // 오름차순 정렬

    // ③ 생성/업데이트
    colorsToUse.forEach(col => {
      sizesToUse.forEach(sz => {
        // 라벨 생성
        let labelValue = (template['제품선택'] || template['추가상품값'] || '').toString();
        if (useColorInLabel && col) labelValue = buildLabelInsertColorAfterProductForCodeFile(code, fileName, template, col);
        if (useSizeInLabel && sz)  labelValue = replaceLastSizeTokenInLabel(labelValue, sz);

        // 기존 존재 여부
        const existIdx = allRows.findIndex(r => {
          if (r.file !== fileName || r.관리코드 !== code) return false;
          if (!rowHasColorWithPattern(r, col, pattern)) return false;
          const existingSize = pattern.parse(r);
          return (existingSize || '') === (sz || '');
        });

        if (existIdx >= 0) {
          // 업데이트 (← 여기서는 row 사용)
          const row = allRows[existIdx];
          row['재고수량'] = stock;

          if (pattern.column === '사이즈') {
   if ('사이즈' in row) row['사이즈'] = pattern.format(sz || '');
   if ('색상' in row && !useColorInLabel) row['색상'] = col || row['색상'];
 } else if (pattern.column === '색상') {
            if ('색상' in row) row['색상'] = pattern.format(sz);
          }
          if ('제품선택'   in row) row['제품선택']   = labelValue;
          if ('추가상품값' in row) row['추가상품값'] = labelValue;

        } else {
          // 신규 추가 (← 여기서는 newRow 사용)
          const newRow = { ...template };
newRow['관리코드'] = code;
if ('상품코드' in newRow) newRow['상품코드'] = code;
if ('코드'     in newRow) newRow['코드']     = code;
newRow._normCode = normCode(code);   // ★ 추가
newRow['재고수량'] = stock;
newRow.file = fileName;


          if (pattern.column === '사이즈') {
   if ('사이즈' in newRow) newRow['사이즈'] = pattern.format(sz || '');
   if ('색상' in newRow && !useColorInLabel) newRow['색상'] = col || (newRow['색상'] || '');
 } else if (pattern.column === '색상') {
            if ('색상' in newRow) newRow['색상'] = pattern.format(sz);
          }
          if ('제품선택'   in newRow) newRow['제품선택']   = labelValue;
          if ('추가상품값' in newRow) newRow['추가상품값'] = labelValue;

          // 같은 색상 블록 뒤에 삽입
          const lastSameColorIdx = findLastIndex(allRows, r => {
            if (r.file !== fileName || r.관리코드 !== code) return false;
            return rowHasColorWithPattern(r, col, pattern);
          });
          const lastCodeIdx = findLastIndex(allRows, r => r.file === fileName && r.관리코드 === code);
          const insertAt = (lastSameColorIdx >= 0 ? lastSameColorIdx : lastCodeIdx) + 1;
          allRows.splice(insertAt, 0, newRow);
        }
      });

      // ④ 같은 색상 블록을 사이즈 오름차순으로 재정렬
      reorderColorBlock(fileName, code, col, detectSizeDisplayPatternForCodeFile(code, fileName));
    });
  });

// UI 갱신 (옵션 편집 모드에서도 강제로 전체 새로 그림)
const listEl = document.getElementById(`optionList_${code}`);
if (listEl) {
  const rowsForCode = rowsByCode(code);
console.log("[DEBUG] 렌더링 직전:", rowsForCode.map(r => ({
  색상: r['색상'], 사이즈: r['사이즈'], 제품선택: r['제품선택']
})));
listEl.innerHTML = renderOptionListHTML(code);


  // ★ 추가: 숨김된 항목도 강제 표시
  listEl.style.display = "block";
}

const cEl  = document.getElementById(`newColor_${code}`);
const sEl  = document.getElementById(`newSize_${code}`);
const stEl = document.getElementById(`newStock_${code}`);
if (cEl) cEl.value = '';
if (sEl) sEl.value = '';
if (stEl) stEl.value = '99999';

}
// 코드 비교용 표준화: 공백 제거 + 대문자
function normCode(s) {
  return String(s ?? '').replace(/\s+/g, '').toUpperCase();
}

  </script>
</body>
</html>
